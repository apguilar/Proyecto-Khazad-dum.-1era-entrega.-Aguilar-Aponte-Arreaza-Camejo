#include <iostream>
#include <string>
#include <chrono> //Para el tiempo de espera entre interfases
#include <thread> //Permite que se utilize el anterior
#include <cstdlib>



using namespace std;









// ESTRUCTURAS ESPECIES ORCOS Y HeROES. PERSONAJES DE HeROES. 

struct Especie_Heroe { 
    string nombre_especie;
    int fortaleza_base;
    int salud_base;
    int rapidez_base;
    Especie_Heroe *siguiente;
};

// Estructura Especie de Orco
struct Especie_Orco {
    string nombre_especie;
    int dano_base;
    int salud_base;
    int rapidez_base;
    Especie_Orco* siguiente;
};

struct Heroe {
    string nombre;
    Especie_Heroe *especie;                  // Puntero a una Especie_Heroe  
    //Implemento *mochila;                    // Dato para seccion JUGAR. MOCHILA: Lista de implementos, se admitira un limite de 5 implementos 
    Heroe *siguiente;                     
};

// Estructura para gestionar la lista de especies
struct ListaEspecies {
    Especie_Heroe* cabeza;
    int cantidadEspecies;
};

// Estructura para gestionar la lista de heroes
struct ListaHeroes {
    Heroe* cabeza;
    int cantidad;
    ListaEspecies* listaEspeciesGlobal;
};













// ESTRUCTURA ARMA, CURA, DEFENSA Y PODER MaGICO. IMPLEMENTO QUE CONTIENE UNO SOLO DE TODOS.

// Estructura Armas
struct Arma {                 
    string nombre;             
    int durabilidad_base;              // Durabilidad en usos.
    //int durabilidad_actual;          // Dato para seccion JUGAR. Comenzaria = a durabilidad y se va restando. Al llegar a 0, se inhabilita su uso.
    int dano_base;                     // Cantidad de dano por ataque.
    int fortaleza_requerida;           // Fortaleza minima del heroe para utilizarla.
    Arma *siguiente;
};

// Estructura Cura
struct Cura {            
    string nombre;
    int uso_maximo;              // Puede ser x5, x10, etc., dependiendo de cuantas veces pueda aplicarla
    //int uso_actual;            // Dato para seccion JUGAR. Comenzaria = a uso_maximo y se va restando. Al llegar a 0, se inhabilita su uso
    int suma_salud;              // Valor que se agrega a salud. Ej balanceado: +60 HP x2 | +20 HP x5
    Cura *siguiente;
};

// Estructura Defensa (Escudos, chalecos, etc.)    // Se resta a los ataques que se reciban
struct Defensa  {           
    string nombre;
    int durabilidad_base;              // Cada turno en que haya sido utilizada, se le reduce 10%
    //int durabilidad_actual;          // Dato para seccion JUGAR. Comenzaria = a durabilidad y se va restando. Al llegar a 0, se inhabilita su uso.
    int valor_proteccion;              // Se le resta al ataque recibido
    Defensa *siguiente;
};

// Estructura Poder Magico 
// IMPORTANTE: Para esta entrega, los poderes magicos permitiran anadirle cierta cantidad a algun campo del heroe.
//             Proxima entrega, poderes magicos personalizados.

struct Poder_Magico {      
    string nombre;  
    int uso_maximo;              // 1 para unico uso. Se asigna de forma predeterminada.
    //int uso_actual;            // Dato para seccion JUGAR. Comenzaria = a uso_maximo y se va restando. Al llegar a 0, se inhabilita su uso.
    //int modificacion;          // Ej: Sumar valor a cant, Duplicar cant actual x2 sin sobrepasar limite, Invisibilidad por dos turnos, Derrotar a todos los orcos con un solo ataque, Defensa total en la proxima batalla. 
    int valor_modificacion;      // Cantidad de dano, curacion, defensa o cualidad que aporta.
    int campo_modificacion;      // 1= Fortaleza, 2= Rapidez, 3= Ataque, 4= Defensa
    Poder_Magico *siguiente;
};

// Estructura Implemento
// IMPORTANTE: Creado para lista de implementos en mochila.
//             No se trabaja en esta entrega.

struct Implemento {       
    int tipo;                               // Ataque =1, Defensa =2, Cura =3, Poder magico =4. Para saber cual puntero tiene el implemento.
    Arma *implemento_arma;                  // Se apunta a una sola estructura, el resto apunta a NULL.
    Defensa *implemento_defensa;          
    Cura *implemento_cura;
    Poder_Magico *implemento_poder_magico;
    Implemento *siguiente;
};














// ESTRUCTURA SALA.

// Estructura Salas
struct Sala {
    string nombre;
    int id_sala;
    //Salas_Adyacentes *adyacencias;        // Dato para seccion JUGAR.
    //int cantidad_orcos_en_sala;           // Dato para seccion JUGAR.
    Sala *siguiente;
};

// Estructura Sala adyacente                // Estructura utilizada en seccion JUGAR.
/*struct Salas_Adyacentes {
    Sala *sala_adyacente;
    int distancia; 
    Salas_Adyacentes *siguiente;
};*/

// Estructura para gestionar la lista de salas
struct ListaSalas {
    Sala* cabeza;
    int cantidadSalas;
};












// FUNCIONES AUXILIARES

void validarLongitudNombre(string& input, size_t longitudMaxima) {
    while (input.length() > longitudMaxima) {
        cout << "\n----------- ERROR -----------\n";
        cout << "El texto ingresado es: " << input << endl;   
        cout << "Y no debe exceder el limite de " << longitudMaxima << " caracteres.\n";    
        cout << "Intente nuevamente.\n" << endl;
        getline(cin, input);
    }
}

string obtenerNombre(const string& prompt) {
    string input;
    const size_t longitudMaxima = 20; // Longitud maxima permitida

    cout << prompt;
    getline(cin, input);

    // Llama a la funcion para validar la longitud del input
    validarLongitudNombre(input, longitudMaxima);

    return input;
}

string validarLongitudString(const string& prompt, size_t longitud) {
    string input;
    bool valid = false;
    
    while (!valid) {

        std::cout << prompt;                     // Solicitud al usuario
        std::getline(std::cin, input);
        
        if (input.length() > longitud) {
            std::cout << "\n----------- ERROR -----------\n";
            std::cout << "El texto ingresado es: " << input << std::endl;   
            std::cout << "Y excede el limite de " << longitud << " caracteres.\n";    
            std::cout << "Intente nuevamente.\n" << endl; 
        } else {
            valid = true;
        }
    }
    return input;
}

void pausa() {
    cout << "\nPresione ENTER para continuar...";
    cin.get(); 
 
}














// FUNCIONES PARA CREAR (ESPECIES HeROES Y ORCOS, PERSONAJE HeROES, SALA, CADA IMPLEMENTO).

void crearOrco(Especie_Orco*&cabezaOrco, const string& nombre_especieOrco, int dano_baseOrco, int salud_baseOrco, int rapidez_baseOrco) {
    Especie_Orco* nuevoOrco = new Especie_Orco();
    nuevoOrco->nombre_especie = nombre_especieOrco;
    nuevoOrco->dano_base = dano_baseOrco;
    nuevoOrco->salud_base = salud_baseOrco;
    nuevoOrco->rapidez_base = rapidez_baseOrco;
    nuevoOrco->siguiente = nullptr;

    if (cabezaOrco == nullptr) {
        cabezaOrco = nuevoOrco; // Si la lista esta vacia, el nuevo orco sera el primero
    } else {
        Especie_Orco* actualOrco = cabezaOrco;
        while (actualOrco->siguiente != nullptr) {
            actualOrco = actualOrco->siguiente; // Recorre la lista hasta el final
        }
        actualOrco->siguiente = nuevoOrco; // Agrega el nuevo orco al final de la lista
    }
    std::cout << "Orco '" << nombre_especieOrco << "' agregado exitosamente!\n";
}

Especie_Heroe *crearEspecie_Heroe(string nombre, int fortaleza_base, int salud_base, int rapidez_base) {
    Especie_Heroe *nuevo = new Especie_Heroe;
    nuevo->nombre_especie = nombre;
    nuevo->fortaleza_base = fortaleza_base;
    nuevo->salud_base = salud_base;
    nuevo->rapidez_base = rapidez_base;
    nuevo->siguiente = nullptr;
    return nuevo;
}

Heroe *crearHeroe(Especie_Heroe *especie_seleccionada, string nombre) {       
    Heroe *nuevo = new Heroe;
    nuevo->nombre = nombre;
    nuevo->especie = especie_seleccionada;   // La direccion a apuntar sera de la especie asignada por usuario
    //nuevo->mochila = nullptr;
    nuevo->siguiente = nullptr;
    return nuevo; 
}

// Funcion crear sala 
Sala *crearSala(string nombre, int id_sala) {
    Sala *nuevo = new Sala;
    nuevo->nombre = nombre;
    nuevo->id_sala = id_sala;
    //nuevo->cantidad_orcos_en_sala = cantidad_orcos_en_sala;              // Dato para seccion JUGAR.
    nuevo->siguiente = nullptr;
    //nuevo->adyacencias = nullptr;                                        // Dato para seccion JUGAR.
    return nuevo;
}

// Funcion para crear un nuevo nodo (arma)
Arma *crearArma(string nombre, int durabilidad_base, int dano_base, int fortaleza_requerida) { // Pasa el &de la especie selcc
    Arma *nuevo = new Arma;
    nuevo->nombre = nombre;
    nuevo->durabilidad_base = durabilidad_base;
    nuevo->dano_base = dano_base;
    nuevo->fortaleza_requerida = fortaleza_requerida;
    nuevo->siguiente = nullptr;
    return nuevo;
}

// Funcion para crear un nuevo nodo (cura)
Cura *crearCura(string nombre, int uso_maximo, int suma_salud) { 
    Cura *nuevo = new Cura;
    nuevo->nombre = nombre;
    nuevo->uso_maximo = uso_maximo;   
    //nuevo->uso_actual = uso_base;
    nuevo->suma_salud = suma_salud;
    nuevo->siguiente = nullptr;
    return nuevo;
}

// Funcion para crear un nuevo nodo (defensa)
Defensa *crearDefensa(string nombre, int durabilidad_base, int valor_proteccion) { 
    Defensa *nuevo = new Defensa; 
    nuevo->nombre = nombre;
    nuevo->durabilidad_base = durabilidad_base;
    //nuevo->durabilidad_actual = durabilidad_base;
    nuevo->valor_proteccion = valor_proteccion;
    nuevo->siguiente = nullptr;
    return nuevo;
}

// Funcion para crear un nuevo nodo (poder magico)
Poder_Magico *crearPoder_Magico(string nombre, int valor_modificacion, int campo_modificacion) { 
    Poder_Magico *nuevo = new Poder_Magico;
    nuevo->nombre = nombre;
    nuevo->uso_maximo = 1;
    //nuevo->uso_actual = uso_maximo;
    //nuevo->modificacion = modificacion;
    nuevo->valor_modificacion = valor_modificacion;
    nuevo->campo_modificacion = campo_modificacion;
    nuevo->siguiente = nullptr;
    return nuevo;
}















// FUNCIONES SECCIoN HeROES (ESPECIES Y PERSONAJES)

// Funciones para gestionar especies    

void inicializarListaEspecies(ListaEspecies* lista) {
    lista->cabeza = nullptr;
    lista->cantidadEspecies = 0;

    // Anadir una especie predeterminada
    Especie_Heroe* nuevaEspecie = crearEspecie_Heroe("Elfo", 30, 200, 100);
    lista->cabeza = nuevaEspecie;
    lista->cantidadEspecies++;
}


void anadirNuevaEspecieDesdeUsuario(ListaEspecies* lista) {
    system("cls");
    cout << "\n--- Anadir Nueva Especie ---\n";
    string nombre_especie = obtenerNombre("Ingrese el Nombre de la nueva Especie de Heroe (maximo 20 caracteres): ");

    int fortaleza_base;
    cout << "\nIngrese valor de Fortaleza base\n";
    cout << "(Debe ser un numero entero entre 10 y 50, y multiplo de 10. \n";
    cout << "Valores admitidos: 10, 20, 30, 40, 50): " << endl;
    while (!(cin >> fortaleza_base) || fortaleza_base < 10 || fortaleza_base > 50 || fortaleza_base % 10 != 0) {
        cout << "\n----------- ERROR -----------\n";
        cout << "El valor ingresado es: " << fortaleza_base << endl;   
        cout << "Debe ser un numero entre 10 y 50, y multiplo de 10.\n";    
        cout << "Intente nuevamente.\n" << endl;
        cin.clear();
        cin.ignore(10000, '\n');

    }
    cin.ignore();

    int salud_base;
    cout << "\nIngrese valor de Salud base\n";
    cout << "(Debe ser un numero entero entre 100 y 300, y multiplo de 50. \n";
    cout << "Valores admitidos: 100, 150, 200, 250, 300): " << endl;
    while (!(cin >> salud_base) || salud_base < 100 || salud_base > 300 || salud_base % 50 != 0) {
        cout << "\n----------- ERROR -----------\n";
        cout << "El valor ingresado es: " << salud_base << endl;   
        cout << "Debe ser un numero entre 100 y 300, y multiplo de 50.\n";    
        cout << "Intente nuevamente.\n" << endl;
        cin.clear();
        cin.ignore(10000, '\n');
    }
    cin.ignore();

    int rapidez_base;
    cout << "\nIngrese valor de Rapidez base\n";
    cout << "(Debe ser un numero entero entre 50 y 200, y multiplo de 50. \n";
    cout << "Valores admitidos: 50, 100, 150, 200): " << endl;
    while (!(cin >> rapidez_base) || rapidez_base < 50 || rapidez_base > 200 || rapidez_base % 50 != 0) {
        cout << "\n----------- ERROR -----------\n";
        cout << "El valor ingresado es: " << rapidez_base << endl;   
        cout << "Debe ser un numero entre 50 y 200, y multiplo de 50.\n";    
        cout << "Intente nuevamente.\n" << endl;
        cin.clear();
        cin.ignore(10000, '\n');
    }
    cin.ignore();

    // Crear la nueva especie utilizando la funcion crearEspecie_Heroe
    Especie_Heroe* nuevaEspecie = crearEspecie_Heroe(nombre_especie, fortaleza_base, salud_base, rapidez_base);

    // Agregar la nueva especie a la lista
    if (lista->cabeza == nullptr) {
        lista->cabeza = nuevaEspecie;
    } else {
        Especie_Heroe* actual = lista->cabeza;
        while (actual->siguiente != nullptr) {
            actual = actual->siguiente;
        }
        actual->siguiente = nuevaEspecie;
    }
    lista->cantidadEspecies++;
    cout << "\nCreando datos...\n"<<endl;
    this_thread::sleep_for(chrono::seconds(3));
    cout << "Especie '" << nombre_especie << "' agregada exitosamente!\n";
    pausa();
}

void mostrarEspecies(const ListaEspecies* lista) {
    if (lista->cabeza == nullptr) {
        std::cout << "\n----- Lista vacia -----\n";
        std::cout << "\nNo hay especies de heroes disponibles.\n";
        pausa();
        return;
    }
    cout << "\n--- Especies de Heroes Disponibles ---\n";
    Especie_Heroe* actual = lista->cabeza;
    int i = 1;

    while (actual != nullptr) {
        cout << i << ". Nombre: " << actual->nombre_especie << endl;
        cout << "   Fortaleza: " << actual->fortaleza_base
             << " | Salud: " << actual->salud_base
             << " | Rapidez: " << actual->rapidez_base << "\n";
        actual = actual->siguiente;
        i++;
    }
    cout << "---------------------------------------------\n";
}
void modificarEspecie(ListaEspecies* listaEspecies) {
    if (listaEspecies->cabeza == nullptr) {
        cout << "\n----- Lista vacia -----\n";
        cout << "\nNo hay Especies de heroes disponibles para modificar.\n";
        pausa();
        return;
    }

    mostrarEspecies(listaEspecies);

    int seleccion;
    cout << "Ingrese el numero de la especie que desea modificar: ";
    cin >> seleccion;
    cin.ignore();

    Especie_Heroe* actual = listaEspecies->cabeza;
    int indice = 1;
    while (actual != nullptr && indice < seleccion) {
        actual = actual->siguiente;
        indice++;
    }

    if (actual == nullptr) {
        std::cout << "----------- ERROR -----------";
        std::cout << "\nSeleccion invalida.";
        cout << "Intente nuevamente.\n."<<endl;
        return;
    }

    int opcion;
    system("cls");
    cout << "\n--- Que desea modificar de la Especie '" << actual->nombre_especie << "'? ---\n";
    cout << "1. Nombre.\n";
    cout << "2. Fortaleza Base.\n";
    cout << "3. Salud Base.\n";
    cout << "4. Rapidez Base.\n"<< endl;
    cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
    cin >> opcion;
    cin.ignore();

    switch (opcion) {
        case 1: {
            string nuevoNombre = obtenerNombre("\nIngrese el nuevo nombre de la Especie " + actual->nombre_especie + ", maximo 20 caracteres: ");
            actual->nombre_especie = nuevoNombre;
            cout << "\nActualizando datos...\n"<<endl;
            this_thread::sleep_for(chrono::seconds(3));
            std::cout << "Nombre de Especie actualizado a '" << actual->nombre_especie << "' correctamente.\n";
            pausa();
            break;
        }
        case 2: {
            int nuevaFortaleza;
            std::cout << "\nIngrese la nueva Fortaleza Base \n";
            std::cout << "Debe ser un numero entero entre 10 y 50, y multiplo de 10: "<<endl;
            while (!(cin >> nuevaFortaleza) || nuevaFortaleza < 10 || nuevaFortaleza > 50 || nuevaFortaleza % 10 != 0) {
                cout << "\n----------- ERROR -----------\n";
                cout << "El valor ingresado es: " << nuevaFortaleza << endl;
                cout << "Debe ser un numero entre 10 y 50, y multiplo de 10.\n";
                cout << "Intente nuevamente.\n" << endl;
                cin.clear();
                cin.ignore(10000, '\n');
            }
            actual->fortaleza_base = nuevaFortaleza;
            cout << "\nActualizando datos...\n"<<endl;
            this_thread::sleep_for(chrono::seconds(3));
            cout << "Fortaleza Base de " << actual->nombre_especie << " actualizado a " << actual->fortaleza_base << " correctamente.\n";
            pausa();
            break;
        }
        case 3: {
            int nuevaSalud;
            std::cout << "\nIngrese la nueva Salud Base \n";
            std::cout << "Debe ser un numero entero entre 100 y 300, y multiplo de 50: "<<endl;
            while (!(cin >> nuevaSalud) || nuevaSalud < 100 || nuevaSalud > 300 || nuevaSalud % 50 != 0) {
                cout << "\n----------- ERROR -----------\n";
                cout << "El valor ingresado es: " << nuevaSalud << endl;
                cout << "Debe ser un numero entre 100 y 300, y multiplo de 50.\n";
                cout << "Intente nuevamente.\n" << endl;
                cin.clear();
                cin.ignore(10000, '\n');
            }
            actual->salud_base = nuevaSalud;
            cout << "\nActualizando datos...\n"<<endl;
            this_thread::sleep_for(chrono::seconds(3));
            cout << "Salud Base de " << actual->nombre_especie << " actualizado a " << actual->salud_base << " correctamente.\n";
            pausa();
            break;
        }
        case 4: {
            int nuevaRapidez;
            std::cout << "\nIngrese la nueva Rapidez Base \n";
            std::cout << "Debe ser un numero entero entre 50 y 200, y multiplo de 50: "<<endl;
            while (!(cin >> nuevaRapidez) || nuevaRapidez < 50 || nuevaRapidez > 200 || nuevaRapidez % 50 != 0) {
                cout << "\n----------- ERROR -----------\n";
                cout << "El valor ingresado es: " << nuevaRapidez << endl;
                cout << "Debe ser un numero entre 50 y 200, y multiplo de 50.\n";
                cout << "Intente nuevamente.\n" << endl;
                cin.clear();
                cin.ignore(10000, '\n');
            }
            actual->rapidez_base = nuevaRapidez;
            cout << "\nActualizando datos...\n"<<endl;
            this_thread::sleep_for(chrono::seconds(3));
            cout << "Rapidez Base de " << actual->nombre_especie << " actualizado a " << actual->rapidez_base << " correctamente.\n";
            pausa();
            break;
        }
        default:
            cout << "\nOpcion invalida.\n";
            pausa();
            return;
    }
    cout << "\n"<<endl;
    cout << "\nEspecie '" << actual->nombre_especie << "' modificada exitosamente!\n"<<endl;
    pausa();
}

void eliminarEspecie(ListaHeroes* listaHeroes, ListaEspecies* listaEspecies) {
    if (listaEspecies->cantidadEspecies == 0) {
        cout << "\n----- Lista vacia -----\n";
        cout << "\nNo hay Especies de Heroes disponibles para eliminar.\n";
        pausa();
        return;
    }

    cout << "\n--- Eliminar Especie ---\n";
    mostrarEspecies(listaEspecies);

    int seleccion;
    cout << "Ingrese el numero de la Especie que desea eliminar (1-" << listaEspecies->cantidadEspecies << "): ";
    while (!(cin >> seleccion) || seleccion < 1 || seleccion > listaEspecies->cantidadEspecies) {
        cout << "\n----------- ERROR -----------";
        cout << "\nEl numero ingresado es:" << seleccion << endl;
        cout << "Entrada invalida: Debe ser un numero entero entre 1 y " << listaEspecies->cantidadEspecies << ": ";
        cout << "Intente nuevamente.\n"<<endl;
        cin.clear();
        cin.ignore(10000, '\n');
    }
    cin.ignore();

    Especie_Heroe* actual = listaEspecies->cabeza;
    Especie_Heroe* anterior = nullptr;
    int indice = 1;

    // Buscar la especie seleccionada
    while (actual != nullptr && indice < seleccion) {
        anterior = actual;
        actual = actual->siguiente;
        indice++;
    }

    if (actual == nullptr) {
        cout << "----------- ERROR -----------\n";
        cout << "Seleccion invalida.\n";
        cout << "Intente nuevamente.\n"<<endl;
        return;
    }

    /*// Buscar la especie seleccionada
    Especie_Heroe* especieSeleccionada = listaEspecies->cabeza;
    for (int i = 1; i < especieIndice; ++i) {
        especieSeleccionada = especieSeleccionada->siguiente;
    }*/

    // Buscar Héroe con esa especie
    Heroe* actualx = listaHeroes->cabeza;
    int indicex = 1;

    while (actualx != nullptr && indicex < listaHeroes->cantidad) {
        if ((actualx->especie->nombre_especie)==(actual->nombre_especie)){
            actualx->especie = nullptr;
        }
        actualx = actualx->siguiente; // Mover al siguiente héroe
        indicex++; 

    }

    // Eliminar la especie seleccionada
    if (anterior == nullptr) {
        // Eliminar la primera especie
        listaEspecies->cabeza = actual->siguiente;
    } else {
        // Eliminar una especie intermedia o final
        anterior->siguiente = actual->siguiente;
    }

    delete actual;
    listaEspecies->cantidadEspecies--;
    cout << "\nEliminando datos...\n"<<endl;
    this_thread::sleep_for(chrono::seconds(3));
    cout << "Especie de heroe eliminada exitosamente!\n"<<endl;
    pausa();
}

void limpiarEspecies(ListaEspecies* listaEspecies) {
    Especie_Heroe* actual = listaEspecies->cabeza;
    while (actual != nullptr) {
        Especie_Heroe* siguiente = actual->siguiente;
        delete actual; // Liberar la memoria del nodo actual
        actual = siguiente;
    }
    listaEspecies->cabeza = nullptr; // Asegurarse de que la lista este vacia
    listaEspecies->cantidadEspecies = 0; // Reiniciar el contador de especies
    cout << "La memoria de Especies de Heroes fue eliminada correctamente.\n";
}



// Funciones Heroes PERSONAJES
void inicializarListaHeroes(ListaHeroes* lista, ListaEspecies* listaEspecies) {
    lista->cabeza = nullptr; // Inicializar la lista de heroes como vacia
    lista->cantidad = 0;     // Inicializar el contador de heroes en 0
    lista->listaEspeciesGlobal = listaEspecies; // Asignar la lista de especies global
}

void anadirPersonaje(ListaHeroes* listaHeroes, ListaEspecies* listaEspecies) {
    if (listaEspecies->cantidadEspecies == 0) {
        cout << "\n----- Lista vacia -----\n";
        cout << "\nNo hay especies disponibles.\n";
        pausa();
        return;
    }

    system("cls");
    cout << "\n--- Anadir Nuevo Heroe ---\n";
    string nombre = obtenerNombre("Ingrese el nombre del nuevo Heroe (maximo 20 caracteres): ");

    // Mostrar las especies disponibles
    cout << "\n";
    mostrarEspecies(listaEspecies);

    // Solicitar al usuario que seleccione una especie
    int especieIndice;
    cout << "Seleccione el numero de la especie que desea asignar al nuevo Heroe: ";
    while (!(cin >> especieIndice) || especieIndice < 1 || especieIndice > listaEspecies->cantidadEspecies) {
        cout << "\n----------- ERROR -----------";
        cout << "\nEl numero ingresado es: " << especieIndice;
        cout << "\nSeleccion invalida: Ese numero de Especie no existe en la lista\n";
        cout << "Intente nuevamente.\n"<<endl;
        cin.clear();
        cin.ignore(10000, '\n');
    }
    cin.ignore();

    // Buscar la especie seleccionada
    Especie_Heroe* especieSeleccionada = listaEspecies->cabeza;
    for (int i = 1; i < especieIndice; ++i) {
        especieSeleccionada = especieSeleccionada->siguiente;
    }

    // Crear el nuevo heroe utilizando la funcion crearHeroe
    Heroe* nuevoHeroe = crearHeroe(especieSeleccionada, nombre);

    
    // Agregar el heroe a la lista de heroes
    if (listaHeroes->cabeza == nullptr) {
        listaHeroes->cabeza = nuevoHeroe;
    } else {
        Heroe* actual = listaHeroes->cabeza;
        while (actual->siguiente != nullptr) {
            actual = actual->siguiente;
        }
        actual->siguiente = nuevoHeroe;
    }
    listaHeroes->cantidad++;
    cout << "\nCreando datos...\n"<<endl;
    this_thread::sleep_for(chrono::seconds(3));
    cout << "Heroe '" << nombre << "' agregado exitosamente!\n";
    pausa();
}

void mostrarHeroes(const ListaHeroes* lista) {
    if (lista->cantidad == 0) {
        cout << "\n----- Lista vacia -----\n";
        cout << "\nNo hay heroes en la lista.\n";
        pausa();
        return;
    }

    cout << "\nLista de heroes (" << lista->cantidad << "):\n";
    Heroe* actual = lista->cabeza;
    int i = 1;

    while (actual != nullptr) {
        cout << "\nHeroe #" << i++ << ":\n";
        cout << "   Nombre: " << actual->nombre << " | ";
        if (actual->especie != nullptr) {
            cout << "Especie: " << actual->especie->nombre_especie << endl;
            cout << "   Fortaleza: " << actual->especie->fortaleza_base
                << " | Salud: " << actual->especie->salud_base
                << " | Rapidez: " << actual->especie->rapidez_base << "\n"<<endl;
        } else {
            cout << "Especie: [Datos no disponibles o especie eliminada]\n";
        }
        actual = actual->siguiente;
    }
}

void modificarHeroe(ListaHeroes* listaHeroes, ListaEspecies* listaEspecies) {
    if (listaHeroes->cantidad == 0) {
        cout << "\n----- Lista vacia -----\n";
        cout << "\nNo hay Heroes disponibles para modificar.\n";
        pausa();
        return;
    }

    mostrarHeroes(listaHeroes);

    int indice;
    cout << "Ingrese el numero del heroe que desea modificar: ";
    cin >> indice;
    cin.ignore();

    if (indice < 1 || indice > listaHeroes->cantidad) {
        cout << "----------- ERROR -----------\n";
        cout << "El numero ingresado es:" << indice << endl;
        cout << "\nSeleccion invalida: Ese numero de Heroe no existe en la lista.\n";
        cout << "Intente nuevamente.\n"<<endl;
        return;
    }

    Heroe* actual = listaHeroes->cabeza;
    for (int i = 1; i < indice; ++i) {
        actual = actual->siguiente;
    }

    system("cls");
    cout << "\n--- Que desea modificar del Heroe '" << actual->nombre << "'? ---\n";
    cout << "1. Nombre.\n";
    cout << "2. Especie.\n"<<endl;
    cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: "<<endl;
    int opcion;
    cin >> opcion;
    cin.ignore();

    switch (opcion) {
        case 1: {
            string nuevoNombre = obtenerNombre("\nIngrese el nuevo nombre del Heroe " + actual->nombre + ", maximo 20 caracteres: ");
            actual->nombre = nuevoNombre;
            cout << "\nActualizando datos...\n"<<endl;
            this_thread::sleep_for(chrono::seconds(3));
            std::cout << "Nombre de Heroe actualizado a '" << actual->nombre << "' correctamente.\n";
            pausa();
            break;
        }
        case 2: {
            mostrarEspecies(listaEspecies);
            int especieIndice;
            cout << "Ingrese el numero correspondiente a la nueva Especie: ";
            cin >> especieIndice;
            cin.ignore();

            if (especieIndice < 1 || especieIndice > listaEspecies->cantidadEspecies) {
                cout << "----------- ERROR -----------\n";
                cout << "El numero ingresado es:" << especieIndice;
                cout << "\nSeleccion invalida: Ese numero de Especie no existe en la lista.\n";
                cout << "Intente nuevamente.\n"<<endl;
                return;
            }

            Especie_Heroe* especieActual = listaEspecies->cabeza;
            for (int i = 1; i < especieIndice; ++i) {
                especieActual = especieActual->siguiente;
            }

            actual->especie = especieActual;
            cout << "\nActualizando datos...\n"<<endl;
            this_thread::sleep_for(chrono::seconds(3));
            cout << "Especie del Heroe " << actual->nombre << " actualizado a " << actual->especie->nombre_especie << " correctamente.\n";
            pausa();
            break;
        }
        default:
            cout << "\nOpcion invalida. Operacion cancelada.\n";
            pausa();
    }

    cout << "\nHeroe '" << actual->nombre << "' modificado exitosamente!\n";
    pausa();
}

void eliminarHeroe(ListaHeroes* listaHeroes) {
    if (listaHeroes->cantidad == 0) {
        cout << "\n----- Lista vacia -----\n";
        cout << "\nNo hay Heroes disponibles para eliminar.\n";
        pausa();
        return;
    }

    mostrarHeroes(listaHeroes);

    int indice;
    cout << "Ingrese el numero del Heroe que desea eliminar (1-" << listaHeroes->cantidad << "): ";
    cin >> indice;
    cin.ignore();

    if (indice < 1 || indice > listaHeroes->cantidad) {
        cout << "----------- ERROR -----------\n";
        cout << "\nEl numero ingresado es:" << indice;
        cout << "Entrada invalida: Debe ser un numero entero entre 1 y " << listaHeroes->cantidad << ": \n";
        cout << "Cancelando operacion...\n"<<endl;
        this_thread::sleep_for(chrono::seconds(3));
        return;
    }

    Heroe* actual = listaHeroes->cabeza;
    Heroe* anterior = nullptr;

    for (int i = 1; i < indice; ++i) {
        anterior = actual;
        actual = actual->siguiente;
    }

    if (anterior == nullptr) {
        // Eliminar el primer heroe
        listaHeroes->cabeza = actual->siguiente;
    } else {
        // Eliminar un heroe intermedio o final
        anterior->siguiente = actual->siguiente;
    }

    delete actual;
    listaHeroes->cantidad--;
    cout << "\nEliminando datos...\n"<<endl;
    this_thread::sleep_for(chrono::seconds(3));
    cout << "Heroe eliminado exitosamente!\n";
    pausa();
};

void limpiarHeroes(ListaHeroes* listaHeroes) {
    Heroe* actual = listaHeroes->cabeza;
    while (actual != nullptr) {
        Heroe* siguiente = actual->siguiente;
        delete actual; // Liberar la memoria del nodo actual
        actual = siguiente;
    }
    listaHeroes->cabeza = nullptr; // Asegurarse de que la lista este vacia
    listaHeroes->cantidad = 0; // Reiniciar el contador de heroes
    cout << "La memoria de Heroes fue eliminada correctamente.\n";
}


// Menus de heroe
void gestionarEspecies(ListaHeroes* listaHeroes, ListaEspecies* listaEspecies) {
    int opcion;
    do {
        system("cls");
        cout << "\n--- GESTION DE ESPECIES ---\n";
        cout << "1. Anadir Nueva Especie.\n";
        cout << "2. Ver Especies Disponibles.\n";
        cout << "3. Modificar Especie.\n";
        cout << "4. Eliminar Especie\n";
        cout << "5. Volver al Menu Anterior.\n"<<endl;
        cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        cin >> opcion;
        
        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcion) {
            case 1:
                anadirNuevaEspecieDesdeUsuario(listaEspecies);
                break;
            case 2:
                mostrarEspecies(listaEspecies);
                pausa();
                break;
            case 3:
                modificarEspecie(listaEspecies);
                break;
            case 4:
                eliminarEspecie(listaHeroes, listaEspecies);
                break;
            case 5:
                cout << "\nVolviendo al menu anterior...\n";
                this_thread::sleep_for(chrono::seconds(3));
                system("cls");
                break;
            default:
                cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcion != 5);
}

void gestionarPersonajes(ListaHeroes* listaHeroes, ListaEspecies* listaEspecies) {
    int opcion;
    do {
        system("cls");
        cout << "\n--- GESTION DE PERSONAJES ---\n";
        cout << "1. Agregar Heroe.\n";
        cout << "2. Ver Heroes Disponibles.\n";
        cout << "3. Modificar Heroe.\n";
        cout << "4. Eliminar Heroe.\n";
        cout << "5. Volver al menu Anterior.\n";
        cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        cin >> opcion;
        
        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcion) {
            case 1:
                anadirPersonaje(listaHeroes, listaEspecies);
                break;
            case 2:
                mostrarHeroes(listaHeroes);
                pausa();
                break;
            case 3:
                modificarHeroe(listaHeroes, listaEspecies);
                break;
            case 4:
                eliminarHeroe(listaHeroes);
                break;
            case 5:
                cout << "\nVolviendo al menu anterior...\n";
                this_thread::sleep_for(chrono::seconds(3));
                system("cls");
                break;
            default:
                cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcion != 5);
}






















// Clase para gestionar la lista de Armas
class ListaArma {
private:
    Arma* cabeza;
    size_t cantidadArma; // Para mantener la cuenta

public:
    ListaArma() : cabeza(nullptr), cantidadArma(0) {          // Inicializa cabeza y cantidad   

        // Arma predeterminadas al iniciar
        agregarArma(crearArma("Bola de Fuego", 30, 20, 10));
    }

    // Destructor para liberar la memoria de las armas
    ~ListaArma() {
        limpiarArma(); 
    }

    void limpiarArma() {
        Arma* actual = cabeza;
        while (actual != nullptr) {
            Arma* temp = actual;
            actual = actual->siguiente;
            delete temp;
        }
        cabeza = nullptr;
        cantidadArma = 0; 
        std::cout << "La memoria de Armas fue eliminada correctamente.\n";  
    }

    // Funcion para agregar nodo a la lista
    void agregarArma(Arma* nuevaArma) {
        if (cabeza == nullptr) {
            cabeza = nuevaArma;
        } else {
            Arma* actual = cabeza;
            while (actual->siguiente != nullptr) {
                actual = actual->siguiente;
            }
            actual->siguiente = nuevaArma;
        }
        cantidadArma++;
    }

    // Mostrar la lista de Armas
    void mostrarArma() const {
        if (cabeza == nullptr) {
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay Armas disponibles.\n";
            pausa();
            return;
        }
        std::cout << "\n----- Armas Disponibles -----\n" << endl;
        Arma* actual = cabeza;
        size_t i = 1;

        while (actual != nullptr) {
            std::cout << i << ". " << actual->nombre << endl;                    
            std::cout << "   Durabilidad en usos: " << actual->durabilidad_base
                 << " | Dano base: " << actual->dano_base
                 << " |  Fortaleza minima requerida del heroe para utilizarla: " << actual->fortaleza_requerida << "\n" << endl;
            actual = actual->siguiente;
            i++;
        }
        std::cout << "----------------------------\n";
    }


    // Obtener una arma por indice 
    Arma *obtenerArmaPorIndice(size_t index) const {
        if (index >= cantidadArma) {
            return nullptr;                                           // indice invalido
        }
        Arma *actual = cabeza;
        for (size_t i = 0; i < index; ++i) {
            actual = actual->siguiente;
        }
        return actual;
    }

    // Obtener una especie por nombre (util para personajes predeterminados)
    Arma *obtenerArmaPorNombre(const string& nombreBuscado) const {
        Arma* actual = cabeza;
        while (actual != nullptr) {
            if (actual->nombre == nombreBuscado) {
                return actual;
            }
            actual = actual->siguiente;
        }
        return nullptr; 
    }
    


    // Funcion para anadir una nueva ARMA por parte del usuario
    void anadirArma() {
        system("cls");
        std::cout << "\n----- Crear Nueva Arma -----\n";
        string nombre = validarLongitudString("Ingrese el Nombre de la nueva Arma (maximo 20 caracteres): ", 20);

        int durabilidad_base;
        std::cout << "\nIngrese valor de Durabilidad base (Cantidad de usos permitidos)\n";
        std::cout << "(Debe ser un numero entero entre 1 y 40): "<< endl;
        while (!(std::cin >> durabilidad_base) || durabilidad_base < 1 || durabilidad_base > 40) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El valor ingresado es: " << durabilidad_base << endl;   
            std::cout << "Debe ser un numero entre 1 y 40.\n";    
            std::cout << "Intente nuevamente.\n" << endl;
        
            std::cin.clear();
            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        std::cin.ignore(); // Limpiar el buffer

        int dano_base;
        std::cout << "\nIngrese valor de Dano base\n";
        std::cout << "Debe ser un numero entero entre 20 y 150, y multiplo de 10: ";
        while (!(std::cin >> dano_base) || dano_base < 20 || dano_base > 150 || dano_base % 10 != 0) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El valor ingresado es: " << dano_base << endl;   
            std::cout << "Debe ser un numero entre 20 y 150, y multiplo de 10.\n";    
            std::cout << "Intente nuevamente.\n" << endl;
        
            std::cin.clear();
            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        std::cin.ignore(); // Limpiar el buffer

        int fortaleza_requerida;
        std::cout << "\nIngrese valor de Fortaleza minima que requiere el heroe para utilizarla\n";
        std::cout << "(Debe ser un numero entero entre 10 y 50, y multiplo de 10. \n";
        std::cout << "Valores admitidos: 10, 20, 30, 40, 50): ";
        while (!(std::cin >> fortaleza_requerida) || fortaleza_requerida < 10 || fortaleza_requerida > 50 || fortaleza_requerida % 10 != 0) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El valor ingresado es: " << fortaleza_requerida << endl;   
            std::cout << "Debe ser un numero entre 10 y 50, y multiplo de 10.\n";    
            std::cout << "Intente nuevamente.\n" << endl;
            std::cin.clear();
            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        std::cin.ignore(); // Limpiar el buffer

        agregarArma(crearArma(nombre, durabilidad_base, dano_base, fortaleza_requerida));
        cout << "\nCreando datos...\n"<<endl;
        this_thread::sleep_for(chrono::seconds(3));
        std::cout << "Arma '" << nombre << "' agregada exitosamente!\n";
        pausa();
        
    }

    // Funcion para modificar un ARMA existente
    void modificarArma() {
        if (cabeza == nullptr) { // Revisa si la lista esta vacia
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay Armas disponibles para modificar.\n"; 
            pausa();
            return;
        }

        mostrarArma();
        std::cout << "\nIngrese el numero del Arma a modificar (1-" << obtenerCantidadArma() << "): ";
        size_t pos;
        std::cin >> pos;
        std::cin.ignore();

        if (pos < 1 || pos > obtenerCantidadArma()) {
            std::cout << "Numero de Arma invalido.\n";
            return;
        }

        Arma* armaAModificar = obtenerArmaPorIndice(pos - 1);

        std::cout << "\nModificando Arma: " << armaAModificar->nombre << "\n";

        int opcionModificar;
        do {
            system("cls");
            std::cout << "\n--- Que desea modificar del Implemento '" << armaAModificar->nombre << "'? ---\n";
            std::cout << "1. Nombre.\n";
            std::cout << "2. Durabilidad base (Cantidad de usos permitidos).\n";
            std::cout << "3. Dano base.\n";
            std::cout << "4. Fortaleza minima que requiere el heroe para utilizarla.\n";
            std::cout << "5. Finalizar modificacion.\n"<<endl;
            std::cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
            std::cin >> opcionModificar;
            cin.clear();
            (cin.ignore(1000,'\n'));

            switch (opcionModificar) {
                case 1: {
                    string nuevoNombreArma = validarLongitudString("Ingrese el nuevo nombre para el Arma " + armaAModificar->nombre + ", maximo 20 caracteres: ", 20);
                    armaAModificar->nombre = nuevoNombreArma;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Nombre de Arma actualizado a '" << armaAModificar->nombre << "' correctamente.\n";
                    pausa();
                    break;
                }

                case 2: 
                    int nuevadurabilidad_base;
                    std::cout << "Ingrese la nueva Durabilidad base \n";
                    std::cout << "Debe ser un numero entero entre 1 y 40: ";
                    while (!(std::cin >> nuevadurabilidad_base) || nuevadurabilidad_base < 1 || nuevadurabilidad_base > 40) {
                        std::cout << "Entrada invalida. Ingrese un numero entre 1 y 40";
                        std::cin.clear();
                        std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                    }
                    std::cin.ignore();
                    armaAModificar->durabilidad_base = nuevadurabilidad_base;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Durabilidad base de " << armaAModificar->nombre << " actualizada a " << armaAModificar->durabilidad_base << " correctamente.\n";
                    pausa();
                    break;
                
                case 3: 
                    int nuevodano_base;
                    std::cout << "Ingrese el nuevo Dano base \n";
                    std::cout << "Debe ser un numero entre 20 y 150, y multiplo de 10: ";
                    while (!(std::cin >> nuevodano_base) || nuevodano_base < 20 || nuevodano_base > 150 || nuevodano_base % 10 != 0) {
                        std::cout << "Entrada invalida. Ingrese un numero entre 20 y 150, y multiplo de 10: ";
                        std::cin.clear();
                        std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                    }
                    std::cin.ignore();
                    armaAModificar->dano_base = nuevodano_base;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Dano base de " << armaAModificar->nombre << " actualizado a " << armaAModificar->dano_base << " correctamente.\n";
                    pausa();
                    break;
                
                case 4: 
                    int nuevafortaleza_requerida;
                    std::cout << "Ingrese la nueva Fortaleza requerida (" << armaAModificar->fortaleza_requerida << " - debe ser un numero entre 10 y 50, y multiplo de 10): ";
                    while (!(std::cin >> nuevafortaleza_requerida) || nuevafortaleza_requerida < 10 || nuevafortaleza_requerida > 50 || nuevafortaleza_requerida % 10 != 0) {
                        std::cout << "Entrada invalida. Ingrese un numero entre 10 y 50, y multiplo de 10: ";
                        std::cin.clear();
                        std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                    }
                    std::cin.ignore();
                    armaAModificar->fortaleza_requerida = nuevafortaleza_requerida;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Fortaleza requerida de " << armaAModificar->nombre << " actualizada a " << armaAModificar->fortaleza_requerida << " correctamente.\n";
                    pausa();
                    break;
                
                case 5: 
                    std::cout << "Modificaciones realizadas correctamente...\n"<<endl;
                    std::cout << "Regresando al menu anterior...\n";
                    this_thread::sleep_for(chrono::seconds(3));
                    break;
                
                default: 
                    std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                    pausa();
                
            }
        } while (opcionModificar != 5);

        std::cout << "\nEl Arma '" << armaAModificar->nombre << "' fue modificada exitosamente!\n";
        pausa();
    }


// Eliminar (Quitar un arma de la lista)
    void eliminarArma() {
        if (obtenerCantidadArma() == 0) {
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay armas disponibles para eliminar.\n";
            pausa();
            return;
        }

        mostrarArma();
        std::cout << "\nIngrese el numero del Arma a eliminar (1-" << obtenerCantidadArma() << "): ";  
        size_t pos;
        std::cin >> pos;
        std::cin.ignore();

        if (pos < 1 || pos > obtenerCantidadArma()) {
            std::cout << "Posicion invalida.\n";
            return;
        }


        Arma* actual = cabeza;
        Arma* anterior = nullptr;

        if (pos == 1) {
            cabeza = cabeza->siguiente;
            std::cout << "Eliminando Arma: " << actual->nombre << endl;
            delete actual;
        } else {
            for (size_t i = 1; i < pos; i++) {
                anterior = actual;
                actual = actual->siguiente;
            }
            anterior->siguiente = actual->siguiente;
            std::cout << "Eliminando Arma: " << actual->nombre << endl;
            delete actual;
        }

        cantidadArma--;
        cout << "\nEliminando datos...\n"<<endl;
        this_thread::sleep_for(chrono::seconds(3));
        std::cout << "Arma eliminada exitosamente!\n";
        pausa();
    }

    size_t obtenerCantidadArma() const {
        return cantidadArma;
    }
};

// Funcion para el menu de gestion de Armas
void gestionarArma() {
    ListaArma ListaArma;
    int opcionArma;
    do {
        system("cls");
        std::cout << "\n--- GESTION DE ARMAS ---\n";
        std::cout << "1. Anadir Nueva Arma.\n";
        std::cout << "2. Ver Armas Disponibles.\n";
        std::cout << "3. Modificar Arma Existente.\n";
        std::cout << "4. Eliminar Arma.\n";
        std::cout << "5. Volver al menu anterior.\n"<<endl;
        std::cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        std::cin >> opcionArma;
        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcionArma) {
            case 1:
                ListaArma.anadirArma();
                break;
            case 2:
                ListaArma.mostrarArma();
                pausa();
                break;
            case 3:
                ListaArma.modificarArma();
                break;
            case 4:
                ListaArma.eliminarArma();
                break; 
            case 5:    
                std::cout << "Volviendo al menu anterior...\n";
                this_thread::sleep_for(chrono::seconds(3));
                break;
            default:
                std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcionArma != 5);
}


























// Clase para gestionar la lista de Defensa
class ListaDefensa {
private:
    Defensa* cabeza;
    size_t cantidadDefensa; // Para mantener la cuenta

public:
    ListaDefensa() : cabeza(nullptr), cantidadDefensa(0) {          // Inicializa cabeza y cantidad   

        // Defensa predeterminadas al iniciar
        agregarDefensa(crearDefensa("Escudo de hierro", 20, 30));
    };

    // Destructor para liberar la memoria de las Defensas
    ~ListaDefensa() {
        limpiarDefensa(); 
    }

    void limpiarDefensa() {
        Defensa* actual = cabeza;
        while (actual != nullptr) {
            Defensa* temp = actual;
            actual = actual->siguiente;
            delete temp;
        }
        cabeza = nullptr;
        cantidadDefensa = 0; 
        std::cout << "La memoria de Implementos de Defensa fue eliminada correctamente.\n";
    }

    // Funcion para agregar una Defensa a la lista
    void agregarDefensa(Defensa* nuevaDefensa) {
        if (cabeza == nullptr) {
            cabeza = nuevaDefensa;
        } else {
            Defensa* actual = cabeza;
            while (actual->siguiente != nullptr) {
                actual = actual->siguiente;
            }
            actual->siguiente = nuevaDefensa;
        }
        cantidadDefensa++;
    }

    // Mostrar la lista de Defensas
    void mostrarDefensa() const {
        if (cabeza == nullptr) {
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay implementos de Defensa disponibles.\n";
            pausa();
            return;
        }
        std::cout << "\n----- Implementos de Defensa Disponibles -----\n" << endl;
        Defensa* actual = cabeza;
        size_t i = 1;

        while (actual != nullptr) {
            std::cout << i << "Nombre: " << actual->nombre << endl;                    
            std::cout << "   Durabilidad: " << actual->durabilidad_base
                 << " | Valor proteccion : " << actual->valor_proteccion;
            actual = actual->siguiente;
            i++;
        }
        std::cout << "----------------------------\n"<<endl;
    }


    // Obtener una Defensa por indice 
    Defensa *obtenerDefensaPorIndice(size_t index) const {
        if (index >= cantidadDefensa) {
            return nullptr;                                           // indice invalido
        }
        Defensa *actual = cabeza;
        for (size_t i = 0; i < index; ++i) {
            actual = actual->siguiente;
        }
        return actual;
    }

    // Obtener una especie por nombre (util para personajes predeterminados)
    Defensa *obtenerDefensaPorNombre(const string& nombreBuscado) const {
        Defensa* actual = cabeza;
        while (actual != nullptr) {
            if (actual->nombre == nombreBuscado) {
                return actual;
            }
            actual = actual->siguiente;
        }
        return nullptr; // No se encontro la especie
    }

    size_t obtenerCantidadDefensa() const {
        return cantidadDefensa;             // Retorna la cuenta
    }


    // Funcion para anadir una nueva Defensa por parte del usuario
    void anadirDefensa() {
        system("cls");
        std::cout << "\n----- Crear Nueva Defensa -----\n";
        string nombre = validarLongitudString("Ingrese el Nombre de la nueva Defensa (maximo 20 caracteres): ", 20);

        int durabilidad_base;
        std::cout << "\nIngrese valor de Durabilidad base (Cantidad de usos permitidos)\n";
        std::cout << "Debe ser un numero entero entre 1 y 40: ";
        while (!(std::cin >> durabilidad_base) || durabilidad_base < 1 || durabilidad_base > 40) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El valor ingresado es: " << durabilidad_base << endl;   
            std::cout << "Debe ser un numero entre 1 y 40.\n";    
            std::cout << "Intente nuevamente.\n" << endl;
        
            std::cin.clear();
            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        std::cin.ignore(); // Limpiar el buffer

   
        int valor_proteccion;
        std::cout << "\nIngrese valor de Proteccion que brinda al heroe\n";
        std::cout << "(Debe ser un numero entero entre 30 y 100, y multiplo de 10): ";
        while (!(std::cin >> valor_proteccion) || valor_proteccion < 30 || valor_proteccion > 100 || valor_proteccion % 10 != 0) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El valor ingresado es: " << valor_proteccion << endl;   
            std::cout << "Debe ser un numero entre 30 y 100, y multiplo de 10.\n";    
            std::cout << "Intente nuevamente.\n" << endl;
        
            std::cin.clear();
            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        std::cin.ignore(); // Limpiar el buffer
    
        agregarDefensa(crearDefensa(nombre, durabilidad_base, valor_proteccion));
        cout << "\nCreando datos...\n"<<endl;
        this_thread::sleep_for(chrono::seconds(3));
        std::cout << "Implemento de Defensa '" << nombre << "' agregado exitosamente!\n";
        pausa();
    }


        // Nueva funcion para modificar una Defensa existente
    void modificarDefensa() {
        if (cabeza == nullptr) { // Revisa si la lista esta vacia
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay Implementos de Defensa disponibles.\n"; 
            pausa();
            return;
        }

        mostrarDefensa();
        std::cout << "\nIngrese el numero de la Defensa a modificar (1-" << obtenerCantidadDefensa() << "): ";
        size_t pos;
        std::cin >> pos;
        std::cin.ignore();

        if (pos < 1 || pos > obtenerCantidadDefensa()) {
            std::cout << "Numero de Defensa invalido.\n";
            return;


        }
        

        Defensa* DefensaAModificar = obtenerDefensaPorIndice(pos - 1);

        std::cout << "\nModificando Implemento de Defensa: " << DefensaAModificar->nombre << "\n";

        int opcionModificar;
        do {
            system("cls");
            std::cout << "\n--- Que desea modificar del Implemento '" << DefensaAModificar->nombre << "'? ---\n";
            std::cout << "1. Nombre.\n";
            std::cout << "2. Durabilidad base (Durabilidad en usos).\n";
            std::cout << "3. Valor de Proteccion.\n";
            std::cout << "4. Finalizar modificacion.\n"<<endl;
            std::cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
            std::cin >> opcionModificar;
            
            cin.clear();
            (cin.ignore(1000,'\n'));


            switch (opcionModificar) {
                case 1: {
                    string nuevoNombreDefensa = validarLongitudString("Ingrese el nuevo nombre para la Defensa " + DefensaAModificar->nombre + ", maximo 20 caracteres: ", 20);
                    DefensaAModificar->nombre = nuevoNombreDefensa;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Nombre de Defensa actualizado a '" << DefensaAModificar->nombre << "'.\n";
                    pausa();
                    break;
                }
                case 2: {
                    int nuevadurabilidad_base;
                    std::cout << "Ingrese la nueva Durabilidad base: \n";
                    std::cout << "Debe ser un numero entero entre 1 y 40: ";
                    while (!(std::cin >> nuevadurabilidad_base) || nuevadurabilidad_base < 1 || nuevadurabilidad_base > 40) {
                        std::cout << "Entrada invalida. Ingrese un numero entre 1 y 40";
                        std::cin.clear();
                        std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                    }
                    std::cin.ignore();
                    DefensaAModificar->durabilidad_base = nuevadurabilidad_base;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Durabilidad base de " << DefensaAModificar->nombre << " actualizada a " << DefensaAModificar->durabilidad_base << " correctamente.\n";
                    pausa();
                    break;
                }
                case 3: {
                    int nuevovalor_proteccion;
                    std::cout << "Ingrese el nuevo valor de Proteccion: \n";
                    std::cout << "Debe ser un numero entero entre 30 y 100, y multiplo de 10: ";
                    while (!(std::cin >> nuevovalor_proteccion) || nuevovalor_proteccion < 30 || nuevovalor_proteccion > 100 || nuevovalor_proteccion % 10 != 0) {
                        std::cout << "Entrada invalida. Ingrese un numero entre 30 y 100, y multiplo de 10: ";
                        std::cin.clear();
                        std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                    }
                    std::cin.ignore();
                    DefensaAModificar->valor_proteccion = nuevovalor_proteccion;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Valor de Proteccion de " << DefensaAModificar->nombre << " actualizada a " << DefensaAModificar->valor_proteccion << " correctamente.\n";
                    pausa();
                    break;
                }
                case 4:
                    std::cout << "Modificaciones realizadas correctamente...\n"<<endl;
                    std::cout << "Regresando al menu anterior...\n";
                    this_thread::sleep_for(chrono::seconds(3));
                    break;
                default:
                    std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                    pausa();
            }
        } while (opcionModificar != 4);

        std::cout << "\nEl implemento de Defensa '" << DefensaAModificar->nombre << "' fue modificado exitosamente!\n";
        pausa();
    }


    void eliminarDefensa() {
        if (obtenerCantidadDefensa() == 0) {
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay implementos de Defensa disponibles para eliminar.\n";
            pausa();
            return;
        }

        mostrarDefensa();
        std::cout << "\nIngrese el numero del implemento de Defensa a eliminar (1-" << obtenerCantidadDefensa() << "): ";
        size_t pos;
        std::cin >> pos;
        std::cin.ignore();


        if (pos < 1 || pos > obtenerCantidadDefensa()) {
            std::cout << "Posicion invalida.\n";
            return;
        }

        Defensa* actual = cabeza;
        Defensa* anterior = nullptr;

        if (pos == 1) {
            cabeza = cabeza->siguiente;
            std::cout << "Eliminando implemento de Defensa: " << actual->nombre << endl;
            delete actual;
        } else {
            for (size_t i = 1; i < pos; i++) {
                anterior = actual;
                actual = actual->siguiente;
            }
            anterior->siguiente = actual->siguiente;
            std::cout << "Eliminando implemento de Defensa: " << actual->nombre << endl;
            delete actual;
        }

        cantidadDefensa--;
        cout << "\nEliminando datos...\n"<<endl;
        this_thread::sleep_for(chrono::seconds(3));
        std::cout << "Implemento de Defensa eliminado exitosamente!\n";
        pausa();

    }
    
};



// Funcion para el menu de gestion de Armas
void gestionarDefensa() {
    ListaDefensa ListaDefensa;
    int opcionDefensa;
    do {
        system("cls");
        std::cout << "\n--- GESTION DE DEFENSA ---\n";
        std::cout << "1. Anadir Nuevo implemento de Defensa.\n";
        std::cout << "2. Ver implementos de Defensa Disponibles.\n";
        std::cout << "3. Modificar implemento de Defensa Existente.\n";
        std::cout << "4. Eliminar implemento de Defensa.\n";
        std::cout << "5. Volver al menu anterior.\n"<<endl;
        std::cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        std::cin >> opcionDefensa;
        
        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcionDefensa) {
            case 1: {
                ListaDefensa.anadirDefensa();
                break;
            }
            case 2: {
                ListaDefensa.mostrarDefensa();
                pausa();
                break;
            }
            case 3: {
                ListaDefensa.modificarDefensa();
                break;
            }
            case 4: {
                ListaDefensa.eliminarDefensa();
                break;
            }
            case 5: {
                std::cout << "Volviendo al menu anterior...\n"; 
                this_thread::sleep_for(chrono::seconds(3));
                break;
            }
            default:
                std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcionDefensa != 5);
}
    























// Clase para gestionar la lista de Cura

class ListaCura {
private:
    Cura* cabeza;
    size_t cantidadCura; // Para mantener la cuenta

public:
    ListaCura() : cabeza(nullptr), cantidadCura(0) {          // Inicializa cabeza y cantidad   

        // Arma predeterminadas al iniciar
        agregarCura(crearCura("Brillo de luna", 3, 20));
    }

    // Destructor para liberar la memoria de las Cura
    ~ListaCura() {
        limpiarCura(); 
    }

    void limpiarCura() {
        Cura* actual = cabeza;
        while (actual != nullptr) {
            Cura* temp = actual;
            actual = actual->siguiente;
            delete temp;
        }
        cabeza = nullptr;
        cantidadCura = 0; 
        std::cout << "La memoria de Implementos de Curacion fue eliminada correctamente.\n";
    }

    // Funcion para agregar una Curas a la lista
    void agregarCura(Cura* nuevaCura) {
        if (cabeza == nullptr) {
            cabeza = nuevaCura;
        } else {
            Cura* actual = cabeza;
            while (actual->siguiente != nullptr) {
                actual = actual->siguiente;
            }
            actual->siguiente = nuevaCura;
        }
        cantidadCura++;
    }

 
    // Mostrar la lista de Curas
    void mostrarCura() const {
        if (cabeza == nullptr) {
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay implementos de Curacion disponibles.\n";
            pausa();
            return;
        }
        std::cout << "\n----- Implementos de Curacion Disponibles -----\n" << endl;
        Cura* actual = cabeza;
        size_t i = 1;

        while (actual != nullptr) {
            std::cout << i << ". " << actual->nombre << endl;                    
            std::cout << "   Uso maximo: " << actual->uso_maximo
                 << " |  Valor que aporta a la salud: " << actual->suma_salud<< "\n" << endl;
            actual = actual->siguiente;
            i++;
        }
        std::cout << "----------------------------\n";
    }


    // Obtener una cura por indice 
    Cura *obtenerCuraPorIndice(size_t index) const {
        if (index >= cantidadCura) {
            return nullptr;                                           // indice invalido
        }
        Cura *actual = cabeza;
        for (size_t i = 0; i < index; ++i) {
            actual = actual->siguiente;
        }
        return actual;
    }

    // Obtener una Cura por nombre
    Cura *obtenerCuraPorNombre(const string& nombreBuscado) const {
        Cura* actual = cabeza;
        while (actual != nullptr) {
            if (actual->nombre == nombreBuscado) {
                return actual;
            }
            actual = actual->siguiente;
        }
        return nullptr; 
    }


    // Funcion para anadir una nueva Cura por parte del usuario
    void anadirCura() {
        system("cls");
        std::cout << "\n----- Crear Nuevo implemento de Curacion -----\n";
        string nombre = validarLongitudString("Ingrese el Nombre del nuevo implemento de Curacion (maximo 20 caracteres): ", 20);

        int uso_maximo;
        std::cout << "\nIngrese valor de uso maximo (Cuantas veces puede aplicarse en el heroe)\n";
        std::cout << "(Debe ser un numero entero entre 1 y 10): ";
        while (!(std::cin >> uso_maximo) || uso_maximo < 1 || uso_maximo > 10) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El valor ingresado es: " << uso_maximo << endl;   
            std::cout << "Debe ser un numero entre 1 y 10.\n";    
            std::cout << "Intente nuevamente.\n" << endl;
        
            std::cin.clear();
            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        std::cin.ignore(); // Limpiar el buffer

        int suma_salud;
        std::cout << "\nIngrese valor que aporta a la salud del heroe\n";
        std::cout << "(Debe ser un numero entero entre 30 y 150, y multiplo de 10): ";
        while (!(std::cin >> suma_salud) || suma_salud < 30 || suma_salud > 150 || suma_salud % 10 != 0) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El valor ingresado es: " << suma_salud << endl;   
            std::cout << "Debe ser un numero entre 30 y 150, y multiplo de 10.\n";    
            std::cout << "Intente nuevamente.\n" << endl;
            std::cin.clear();
            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        std::cin.ignore(); // Limpiar el buffer

        agregarCura(crearCura(nombre, uso_maximo, suma_salud));
        cout << "\nCreando datos...\n"<<endl;
        this_thread::sleep_for(chrono::seconds(3));
        std::cout << "Implemento de Curacion '" << nombre << "' agregado exitosamente!\n";
        pausa();
    };

        // Nueva funcion para modificar una Cura existente
        void modificarCura() {
            if (cabeza == nullptr) { // Revisa si la lista esta vacia
                std::cout << "\n----- Lista vacia -----\n";
                std::cout << "\nNo hay implementos de Curacion disponibles para modificar.\n"; 
                pausa();
                return;
            }

            mostrarCura();
            std::cout << "\nIngrese el numero del implemento de Curacion a modificar (1-" << obtenerCantidadCura() << "): ";
            size_t pos;
            std::cin >> pos;
            std::cin.ignore();

            if (pos < 1 || pos > obtenerCantidadCura()) {
                std::cout << "----------- ERROR -----------";
                std::cout << "\nEl numero ingresado es:" << pos;
                std::cout << "\nSeleccion invalida: Ese numero de implemento de Curacion no existe en la lista\n.";
                cout << "Intente nuevamente.\n"<<endl;
                return;
            }

            Cura* curaAModificar = obtenerCuraPorIndice(pos - 1);

            std::cout << "\nModificando implemento de Curacion: " << curaAModificar->nombre << "\n"; //nombreCura

            int opcionModificar;
            do {
                system("cls");
                std::cout << "\n--- Que desea modificar del Implemento '" << curaAModificar->nombre << "'? ---\n";
                std::cout << "1. Nombre.\n";
                std::cout << "2. Uso maximo.\n";
                std::cout << "3. Valor que aporta a la salud.\n";
                std::cout << "4. Finalizar modificacion.\n"<<endl;
                std::cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
                std::cin >> opcionModificar;
                
                cin.clear();
                (cin.ignore(1000,'\n'));

                switch (opcionModificar) {
                    case 1: {
                        string nuevoNombreCura = validarLongitudString("Ingrese el nuevo nombre para el implemento de Curacion " + curaAModificar->nombre + ", maximo 20 caracteres: ", 20);
                        curaAModificar->nombre = nuevoNombreCura;
                        cout << "\nActualizando datos...\n"<<endl;
                        this_thread::sleep_for(chrono::seconds(3));
                        std::cout << "Nombre de implemento de Curacion actualizado a '" << curaAModificar->nombre << "' correctamente.\n";
                        pausa();
                        break;
                    }
                    case 2: {
                        int nuevouso_maximo;
                        std::cout << "Ingrese el nuevo Uso maximo \n";
                        std::cout << "Debe ser un numero entero entre 1 y 10: ";
                        while (!(std::cin >> nuevouso_maximo) || nuevouso_maximo < 1 || nuevouso_maximo > 10) {
                            std::cout << "Entrada invalida. Ingrese un numero entre 1 y 10";
                            std::cin.clear();
                            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                        }
                        std::cin.ignore();
                        curaAModificar->uso_maximo = nuevouso_maximo;
                        cout << "\nActualizando datos...\n"<<endl;
                        this_thread::sleep_for(chrono::seconds(3));
                        std::cout << "Uso maximo de " << curaAModificar->nombre << " actualizado a " << curaAModificar->uso_maximo << " correctamente.\n"; 
                        pausa();
                        break;
                    }
                    case 3: {
                        int nuevasuma_salud;
                        std::cout << "Ingrese el nuevo Valor que aporta a la salud \n"; 
                        std::cout << "Debe ser un numero entero entre 30 y 150, y multiplo de 10: ";
                        while (!(std::cin >> nuevasuma_salud) || nuevasuma_salud < 30 || nuevasuma_salud > 150 || nuevasuma_salud % 10 != 0) {
                            std::cout << "Entrada invalida. Ingrese un numero entre 30 y 150, y multiplo de 10: ";
                            std::cin.clear();
                            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                        }
                        std::cin.ignore();
                        curaAModificar->suma_salud = nuevasuma_salud;
                        cout << "\nActualizando datos...\n"<<endl;
                        this_thread::sleep_for(chrono::seconds(3));
                        std::cout << "Valor que " << curaAModificar->nombre << " aporta a la salud actualizado a " << curaAModificar->suma_salud << " correctamente.\n"; 
                        pausa();
                        break;
                    }
                    case 4: {
                        std::cout << "Modificaciones realizadas correctamente...\n"<<endl;
                        std::cout << "Regresando al menu anterior...\n";
                        this_thread::sleep_for(chrono::seconds(3));
                        break;
                    }
                    default:
                        std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                        pausa();
                }
            } while (opcionModificar != 4);

            std::cout << "\nEl implemento de Curacion '" << curaAModificar->nombre << "' fue modificado exitosamente!\n"<<endl;
            pausa();
        }

// Eliminar (Quitar un cura de la lista)
    void eliminarCura() {
        if (obtenerCantidadCura() == 0) {
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay implementos de Curacion disponibles para eliminar.\n";
            pausa();
            return;
        }

        mostrarCura();
        std::cout << "\nIngrese el numero del implemento de Curacion a eliminar (1-" << obtenerCantidadCura() << "): ";
        size_t pos;
        std::cin >> pos;
        std::cin.ignore();

        if (pos < 1 || pos > obtenerCantidadCura()) {
            std::cout << "----------- ERROR -----------";
            std::cout << "\nEl numero ingresado es:" << pos;
            std::cout << "\nSeleccion invalida: Ese numero de implemento de Curacion no existe en la lista\n.";
            cout << "Intente nuevamente.\n"<<endl;
            return;
        }

        Cura* actual = cabeza;
        Cura* anterior = nullptr;

        if (pos == 1) {
            cabeza = cabeza->siguiente;
            std::cout << "Eliminando implemento de Curacion: " << actual->nombre << endl;
            delete actual;
        } else {
            for (size_t i = 1; i < pos; i++) {
                anterior = actual;
                actual = actual->siguiente;
            }
            anterior->siguiente = actual->siguiente;
            std::cout << "Eliminando implemento de Curacion: " << actual->nombre << endl;
            delete actual;
        }

        cantidadCura--;
        cout << "\nEliminando datos...\n"<<endl;
        this_thread::sleep_for(chrono::seconds(3));
        std::cout << "Implemento de Curacion eliminado exitosamente!\n";
        pausa();
    }

    size_t obtenerCantidadCura() const {  //int 
        return cantidadCura;
    }
};


// Funcion para el menu de gestion de Curas
void gestionarCura() {
    ListaCura listaCura;
    int opcionCura;
    do { 
        system("cls");
        std::cout << "\n--- GESTION DE IMPLEMENTOS DE CURACION ---\n";
        std::cout << "1. Anadir Nuevo implemento de Curacion.\n";
        std::cout << "2. Ver implementos de Curacion Disponibles.\n";
        std::cout << "3. Modificar implemento de Curacion Existente.\n";
        std::cout << "4. Eliminar implemento de Curacion.\n";
        std::cout << "5. Volver al menu anterior.\n"<<endl;
        std::cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        std::cin >> opcionCura;
        
        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcionCura) {
            case 1:
                listaCura.anadirCura();
                break;
            case 2:
                listaCura.mostrarCura();
                pausa();
                break;
            case 3:
                listaCura.modificarCura();
                break;
            case 4:
                listaCura.eliminarCura();
                break;
            case 5:
                std::cout << "Volviendo al menu anterior...\n"; 
                this_thread::sleep_for(chrono::seconds(3));
                break;
            default:
                std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcionCura != 5);
}

























// Clase para gestionar la lista de Poder Magico

class ListaPoder_Magico {
private:
    Poder_Magico* cabeza;
    size_t cantidadPoder_Magico; // Para mantener la cuenta

public:
    ListaPoder_Magico() : cabeza(nullptr), cantidadPoder_Magico(0) {          // Inicializa cabeza y cantidad   

        // PoderMagico predeterminadas al iniciar
        agregarPoder_Magico(crearPoder_Magico("Poder del sol", 20, 1));
    }

    // Destructor para liberar la memoria de las PoderMagico
    ~ListaPoder_Magico() {
        limpiarPoder_Magico(); 
    }

    void limpiarPoder_Magico() {
        Poder_Magico* actual = cabeza;
        while (actual != nullptr) {
            Poder_Magico* temp = actual;
            actual = actual->siguiente;
            delete temp;
        }
        cabeza = nullptr;
        cantidadPoder_Magico = 0; 
        std::cout << "La memoria de Poderes Magicos fue eliminada correctamente.\n";
    }

    // Funcion para agregar una Poder_Magico a la lista
    void agregarPoder_Magico(Poder_Magico* nuevaPoder_Magico) {
        if (cabeza == nullptr) {
            cabeza = nuevaPoder_Magico;
        } else {
            Poder_Magico* actual = cabeza;
            while (actual->siguiente != nullptr) {
                actual = actual->siguiente;
            }
            actual->siguiente = nuevaPoder_Magico;
        }
        cantidadPoder_Magico++;
    }

    // Mostrar la lista de Poder_Magico
    void mostrarPoder_Magico() const {
        if (cabeza == nullptr) {
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay Poderes Magicos disponibles.\n";
            pausa();
            return;
        }
        std::cout << "\n----- Poderes Magicos Disponibles -----\n" << endl;
        Poder_Magico* actual = cabeza;
        size_t i = 1;

        while (actual != nullptr) {
            std::cout << i << ". " << actual->nombre << endl;                    
            std::cout << "   Uso maximo: " << actual->uso_maximo
                 << " | Valor de modificacion (Cantidad sumada al campo): " << actual->valor_modificacion
                 << " | Campo de modificacion (1= Fortaleza, 2= Rapidez, 3= Ataque, 4= Defensa): " << actual->campo_modificacion<< "\n" << endl;
            actual = actual->siguiente;
            i++;
        }
        std::cout << "----------------------------\n";
    }


    // Obtener una Poder_Magico por indice 
    Poder_Magico *obtenerPoderPorIndice(size_t index) const {
        if (index >= cantidadPoder_Magico) {
            return nullptr;                                           // indice invalido
        }
        Poder_Magico *actual = cabeza;
        for (size_t i = 0; i < index; ++i) {
            actual = actual->siguiente;
        }
        return actual;
    }

    // Obtener una Poder_Magico por nombre
    Poder_Magico *obtenerPoderPorNombre(const string& nombreBuscado) const {
        Poder_Magico* actual = cabeza;
        while (actual != nullptr) {
            if (actual->nombre == nombreBuscado) {
                return actual;
            }
            actual = actual->siguiente;
        }
        return nullptr; // No se encontro la especie
    }

    

    // Funcion para anadir una nueva Poder_Magico por parte del usuario
    void anadirPoder_Magico() {
        system("cls");
        std::cout << "\n----- Crear Nuevo Poder Magico -----\n";
        string nombre = validarLongitudString("Ingrese el Nombre del nuevo Poder Magico (maximo 20 caracteres): ", 20);

        int valor_modificacion;
        std::cout << "\nIngrese valor que se sumara al campo seleccionado para el heroe\n";
        std::cout << "Debe ser un numero entero entre 50 y 100, y multiplo de 10: ";
        std::cout << "Valores admitidos: 50, 60, 70, 80, 90): \n" << endl;
        while (!(std::cin >> valor_modificacion) || valor_modificacion < 50 || valor_modificacion > 100 || valor_modificacion % 10 != 0) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El valor ingresado es: " << valor_modificacion << endl;   
            std::cout << "Debe ser un numero entre 50 y 100, y multiplo de 10.\n";    
            std::cout << "Intente nuevamente.\n" << endl;
            std::cin.clear();
            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        std::cin.ignore(); // Limpiar el buffer

        int campo_modificacion;
        std::cout << "\nIngrese el numero correspondiente al campo que desea seleccionar: \n";
        std::cout << "1= Fortaleza, 2= Rapidez, 3= Ataque, 4= Defensa: ";
        while (!(std::cin >> campo_modificacion) || campo_modificacion < 1 || campo_modificacion > 4) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El valor ingresado es: " << campo_modificacion << endl;   
            std::cout << "Debe ser un numero entero entre 1 y 4.\n";    
            std::cout << "Intente nuevamente.\n" << endl;
            std::cin.clear();
            std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        std::cin.ignore(); // Limpiar el buffer

        agregarPoder_Magico(crearPoder_Magico(nombre, valor_modificacion, campo_modificacion));
        cout << "\nCreando datos...\n"<<endl;
        this_thread::sleep_for(chrono::seconds(3));
        std::cout << "Poder Magico '" << nombre << "' agregado exitosamente!\n";
        pausa();
    }

    // Funcion para modificar un Poder_Magico existente
    void modificarPoder_Magico() {
        if (cabeza == nullptr) { // Revisa si la lista esta vacia
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay Poderes Magicos disponibles para modificar.\n"; 
            pausa();
            return;
        }

        mostrarPoder_Magico();
        std::cout << "\nIngrese el numero del Poder Magico a modificar (1-" << obtenerCantidadPoderMagico() << "): ";
        int pos;
        std::cin >> pos;
        std::cin.ignore();

        if (pos < 1 || pos > obtenerCantidadPoderMagico()) {
            std::cout << "----------- ERROR -----------";
            std::cout << "\nEl numero ingresado es:" << pos;
            std::cout << "\nSeleccion invalida: Ese numero de Poder Magico no existe en la lista\n.";
            cout << "Intente nuevamente.\n"<<endl;
            return;
        }

        Poder_Magico* poderAModificar = obtenerPoderPorIndice(pos - 1);

        std::cout << "\nModificando Poder Magico: " << poderAModificar->nombre << "\n"; 

        int opcionModificar;
        do {
            system("cls");
            std::cout << "\n--- Que desea modificar del Poder Magico '" << poderAModificar->nombre << "'? ---\n";
            std::cout << "1. Nombre.\n";
            std::cout << "2. Valor de modificacion.\n";
            std::cout << "3. Campo de modificacion.\n";
            std::cout << "4. Finalizar modificacion.\n"<<endl;
            std::cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
            std::cin >> opcionModificar;
            
            cin.clear();
            (cin.ignore(1000,'\n'));

            switch (opcionModificar) {
                case 1: {
                    string nuevoNombrePoder_Magico = validarLongitudString("Ingrese el nuevo nombre para el Poder Magico " + poderAModificar->nombre + ", maximo 20 caracteres: ", 20);
                    poderAModificar->nombre = nuevoNombrePoder_Magico;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Nombre de Poder Magico actualizado a '" << poderAModificar->nombre<< "' correctamente.\n";
                    pausa();
                    break;
                }
                case 2: {
                    int nuevovalor_modificacion;
                    std::cout << "Ingrese el nuevo Valor de modificacion \n";
                    std::cout << "Debe ser un numero entero entre 50 y 100, y multiplo de 10: ";
                    while (!(std::cin >> nuevovalor_modificacion) || nuevovalor_modificacion < 50 || nuevovalor_modificacion > 100) {
                        std::cout << "Entrada invalida. Ingrese un numero entre 50 y 100, y multiplo de 10.";
                        std::cin.clear();
                        std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                    }
                    std::cin.ignore();
                    poderAModificar->valor_modificacion = nuevovalor_modificacion;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Valor de modificacion de " << poderAModificar->nombre << " actualizado a " << poderAModificar->valor_modificacion << " correctamente.\n";
                    pausa();
                    break;
                }
                case 3: {
                    int nuevocampo_modificacion;
                    std::cout << "Ingrese el nuevo Campo de modificacion \n";
                    std::cout << "(1= Fortaleza, 2= Rapidez, 3= Ataque, 4= Defensa): ";
                    while (!(std::cin >> nuevocampo_modificacion) || nuevocampo_modificacion < 1 || nuevocampo_modificacion > 4) {
                        std::cout << "Entrada invalida. Ingrese un numero entero entre 1 y 4.";
                        std::cin.clear();
                        std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                    }
                    std::cin.ignore();
                    poderAModificar->campo_modificacion = nuevocampo_modificacion;
                    cout << "\nActualizando datos...\n"<<endl;
                    this_thread::sleep_for(chrono::seconds(3));
                    std::cout << "Campo de modificacion de " << poderAModificar->nombre << " actualizado a " << poderAModificar->campo_modificacion << " correctamente.\n";
                    pausa();
                    break;
                }
                case 4:{
                    std::cout << "Modificaciones realizadas correctamente...\n"<<endl;
                    std::cout << "Regresando al menu anterior...\n";
                    this_thread::sleep_for(chrono::seconds(3));
                    break;
                }
                default:
                    std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                    pausa();
            }
        } while (opcionModificar != 4);

        std::cout << "\nEl Poder Magico '" << poderAModificar->nombre << "' fue modificado exitosamente!\n"<<endl;
        pausa();
    }


// Eliminar (Quitar un cura de la lista)
    void eliminarPoder_Magico() {
        if (obtenerCantidadPoderMagico() == 0) {
            std::cout << "\n----- Lista vacia -----\n";
            std::cout << "\nNo hay Poderes Magicos disponibles para eliminar.\n";
            pausa();
            return;
        }

        mostrarPoder_Magico();
        std::cout << "\nIngrese el numero del Poder Magico a eliminar (1-" << obtenerCantidadPoderMagico() << "): ";
        int pos;
        std::cin >> pos;
        std::cin.ignore();

        if (pos < 1 || pos > obtenerCantidadPoderMagico()) {
            std::cout << "----------- ERROR -----------\n";
            std::cout << "El numero ingresado es:" << pos;
            std::cout << "\nSeleccion invalida: Ese numero de Poder Magico no existe en la lista\n.";
            cout << "Intente nuevamente.\n"<<endl;
            return;
        }

        Poder_Magico* actual = cabeza;
        Poder_Magico* anterior = nullptr;

        if (pos == 1) {
            cabeza = cabeza->siguiente;
            std::cout << "Eliminando Poder Magico: " << actual->nombre << endl;
            delete actual;
        } else {
            for (int i = 1; i < pos; i++) {
                anterior = actual;
                actual = actual->siguiente;
            }
            anterior->siguiente = actual->siguiente;
            std::cout << "Eliminando Poder Magico: " << actual->nombre << endl;
            delete actual;
        }

        cantidadPoder_Magico--;
        cout << "\nEliminando datos...\n"<<endl;
        this_thread::sleep_for(chrono::seconds(3));
        std::cout << "Poder Magico eliminado exitosamente!\n";
        pausa();
    }

    int obtenerCantidadPoderMagico() const {
        return cantidadPoder_Magico;
    }
};


// Funcion para el menu de gestion de Poder_Magico
void gestionarPoder_Magico() {
    ListaPoder_Magico listaPoder_Magico;
    int opcionPoder;
    do {
        system("cls");
        std::cout << "\n--- GESTION DE PODERES MaGICOS ---\n";
        std::cout << "1. Anadir Nuevo Poder Magico.\n";
        std::cout << "2. Ver Poderes Magicos Disponibles.\n";
        std::cout << "3. Modificar Poder Magico Existente.\n";
        std::cout << "4. Eliminar Poder Magico.\n";
        std::cout << "5. Volver al menu anterior.\n"<<endl;
        std::cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        std::cin >> opcionPoder;
        
        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcionPoder) {
            case 1:
                listaPoder_Magico.anadirPoder_Magico();
                break;
            case 2:
                listaPoder_Magico.mostrarPoder_Magico();
                pausa();
                break;
            case 3:
                listaPoder_Magico.modificarPoder_Magico();
                break;
            case 4:
                listaPoder_Magico.eliminarPoder_Magico();
                break;
            case 5:
                std::cout << "Volviendo al menu anterior...\n"; 
                this_thread::sleep_for(chrono::seconds(3));
                break;
            default:
                std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcionPoder != 5);
}























// FUNCIONES ORCOS ESPECIE 


Especie_Orco* inicializarEstructura() {
    return nullptr; // Retorna un puntero nulo indicando que esta vacia
}

void mostrarOrcos(Especie_Orco* cabezaOrco) {
    if (cabezaOrco == nullptr) {
        std::cout << "\n----- Lista vacia -----\n";
        std::cout << "\nNo hay orcos disponibles.\n";
        pausa();
        return;
    }

    std::cout << "\n--- Lista de Orcos Registrados ---\n";
    Especie_Orco* actualOrco = cabezaOrco;
    int indiceOrco = 1;
    while (actualOrco != nullptr) {
        std::cout << indiceOrco++ << ". Nombre de la especie: " << actualOrco->nombre_especie << endl;
        std::cout << "   Dano Base: " << actualOrco->dano_base
             << " | Salud Base: " << actualOrco->salud_base
             << " | Rapidez Base: " << actualOrco->rapidez_base << "\n";
        actualOrco = actualOrco->siguiente;
    }
    std::cout << "-----------------------------------\n";
}


//funcion para modificar orcos existente
void modificarOrco(Especie_Orco* cabezaOrco) {
    if (cabezaOrco == nullptr) {
        std::cout << "\n----- Lista vacia -----\n";
        std::cout << "\nNo hay orcos disponibles para modificar.\n";
        pausa();
        return;
    }

    std::cout << "\n--- Orcos disponibles para modificar ---\n";
    mostrarOrcos(cabezaOrco);

    int seleccionOrco;
    std::cout << "Seleccione el numero del orco que desea modificar: ";
    std::cin >> seleccionOrco;

    Especie_Orco *actualOrco = cabezaOrco;
    int indiceOrco = 1;
    while (actualOrco != nullptr && indiceOrco < seleccionOrco) {
        actualOrco = actualOrco->siguiente;
        indiceOrco++;
    }

    if (actualOrco == nullptr) {
        std::cout << "----------- ERROR -----------\n";
        std::cout << "El numero ingresado es:" << actualOrco;
        std::cout << "\nSeleccion invalida: Ese numero de orco no existe en la lista\n"<<endl;
        return;
    }

    int opcionOrco;
    do {
        system("cls");
        std::cout << "\n--- Que desea modificar del Orco '" << actualOrco->nombre_especie << "'? ---\n";
        std::cout << "1. Nombre de la especie.\n";
        std::cout << "2. Dano Base.\n";
        std::cout << "3. Salud Base.\n";
        std::cout << "4. Rapidez Base.\n";
        std::cout << "5. Finalizar modificacion.\n"<<endl;
        std::cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        std::cin >> opcionOrco;

        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcionOrco) {
            case 1: {
                string nuevoNombreOrco = validarLongitudString("Ingrese el nuevo nombre para la especie" + actualOrco->nombre_especie + ", maximo 20 caracteres: ", 20);
                actualOrco->nombre_especie = nuevoNombreOrco;
                cout << "\nActualizando datos...\n"<<endl;
                this_thread::sleep_for(chrono::seconds(3));
                std::cout << "Nombre de Especie de orco actualizado a '" << actualOrco->nombre_especie << "' correctamente.\n";
                pausa();
                break;
            }    
            case 2: {
                int nuevodano_base;
                std::cout << "Ingrese el nuevo Dano base \n";
                std::cout << "Debe ser un numero entero entre 10 y 60, y multiplo de 10: ";
                while (!(std::cin >> nuevodano_base) || nuevodano_base < 10 || nuevodano_base > 60 || nuevodano_base % 10 != 0) {
                    std::cout << "Entrada invalida. Ingrese un numero entre 10 y 60";
                    std::cin.clear();
                    std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                }
                std::cin.ignore();
                actualOrco->dano_base = nuevodano_base;
                cout << "\nActualizando datos...\n"<<endl;
                this_thread::sleep_for(chrono::seconds(3));
                std::cout << "Dano base de " << actualOrco->nombre_especie << " actualizada a " << actualOrco->dano_base << " correctamente.\n";
                pausa();
                break;
            }
            case 3: {
                int nuevasalud_base;
                std::cout << "Ingrese la nueva Salud base \n";
                std::cout << "Debe ser un numero entero entre 100 y 300, y multiplo de 50: ";
                while (!(std::cin >> nuevasalud_base) || nuevasalud_base < 100 || nuevasalud_base > 300 || nuevasalud_base % 50 != 0) {
                    std::cout << "Entrada invalida. Ingrese un numero entre 100 y 500, y multiplo de 50.";
                    std::cin.clear();
                    std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                }
                std::cin.ignore();
                actualOrco->salud_base = nuevasalud_base;
                cout << "\nActualizando datos...\n"<<endl;
                this_thread::sleep_for(chrono::seconds(3));
                std::cout << "Salud base de " << actualOrco->nombre_especie << " actualizada a " << actualOrco->salud_base << " correctamente.\n";
                pausa();
                break;
            }
            case 4: {
                int nuevarapidez_base;
                std::cout << "Ingrese la nueva Rapidez base \n";
                std::cout << "Debe ser un numero entero entre 50 y 200, y multiplo de 50: ";
                std::cout << "(Valores admitidos: 50, 100, 150, 200): \n" << endl;
                while (!(std::cin >> nuevarapidez_base) || nuevarapidez_base < 50 || nuevarapidez_base > 200 || nuevarapidez_base % 50 != 0) {
                    std::cout << "Entrada invalida. Ingrese un numero entre 50 y 200, y multiplo de 50.";
                    std::cin.clear();
                    std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                }
                std::cin.ignore();
                actualOrco->rapidez_base = nuevarapidez_base;
                cout << "\nActualizando datos...\n"<<endl;
                this_thread::sleep_for(chrono::seconds(3));
                std::cout << "Rapidez base de " << actualOrco->nombre_especie << " actualizada a " << actualOrco->rapidez_base << " correctamente.\n";
                pausa();
                break;
            }
            case 5: {
                std::cout << "Modificaciones realizadas correctamente...\n"<<endl;
                std::cout << "Regresando al menu anterior...\n";
                this_thread::sleep_for(chrono::seconds(3));
                break;
            }
            default:
                std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcionOrco != 5);
}

// funcion para eliminar orco existente
void eliminarOrco(Especie_Orco*& cabezaOrco) {
    if (cabezaOrco == nullptr) {
        std::cout << "\n----- Lista vacia -----\n";
        std::cout << "\nNo hay orcos disponibles para eliminar.\n";
        pausa();
        return;
    }

    std::cout << "\n--- Orcos disponibles para eliminar ---\n";
    mostrarOrcos(cabezaOrco);

    int seleccionOrco;
    std::cout << "Seleccione el numero del orco que desea eliminar: ";
    std::cin >> seleccionOrco;

    cin.clear();
    (cin.ignore(1000,'\n'));

    Especie_Orco* actualOrco = cabezaOrco;
    Especie_Orco* anteriorOrco = nullptr;
    int indiceOrco = 1;

    while (actualOrco != nullptr && indiceOrco < seleccionOrco) {
        anteriorOrco = actualOrco;
        actualOrco = actualOrco->siguiente;
        indiceOrco++;
    }

    if (actualOrco == nullptr) {
        std::cout << "----------- ERROR -----------";
        std::cout << "\nEl numero ingresado es:" << actualOrco;
        std::cout << "\nSeleccion invalida: Ese numero de orco no existe en la lista\n.";
        cout << "Intente nuevamente.\n"<<endl;
        return;
    }

    if (anteriorOrco == nullptr) {
        cabezaOrco = actualOrco->siguiente; // Eliminar el primer nodo
    } else {
        anteriorOrco->siguiente = actualOrco->siguiente; // Saltar el nodo actual
    }

    delete actualOrco;
    cout << "\nEliminando datos...\n"<<endl;
    this_thread::sleep_for(chrono::seconds(3));
    std::cout << "Orco eliminado exitosamente!\n";
    pausa();
}

//funcion liberar o limpiar la lista de orcos 
void liberarEstructura(Especie_Orco*& cabezaOrco) {
    Especie_Orco* actualOrco = cabezaOrco;
    while (actualOrco != nullptr) {
        Especie_Orco* tempOrco = actualOrco;
        actualOrco = actualOrco->siguiente;
        delete tempOrco;
    }
    cabezaOrco = nullptr;
    std::cout << "La memoria de Orcos fue eliminada correctamente.\n";
}


//Menu de orcos 
void menuOrcos(Especie_Orco*& cabezaOrco) {
    int opcionOrco = 0;

    do {
        system("cls");
        cout << "\n--- GESTION DE ESPECIES DE ORCOS ---\n";
        cout << "1. Anadir nueva Especie de orco.\n";
        cout << "2. Ver Especies de orcos Disponibles.\n";
        cout << "3. Modificar Especie de Orco Existente.\n";
        cout << "4. Eliminar una Especie de Orco.\n";
        cout << "5. Volver al menu anterior.\n"<<endl;
        cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        cin >> opcionOrco;

        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcionOrco) {
            case 1: {
                std::cout << "\n----- Crear Nueva Especie de Orco -----\n";
                string nombre = validarLongitudString("Ingrese el Nombre de la nueva Especie de Orco (maximo 20 caracteres): ", 20);

                int dano_base;
                std::cout << "Ingrese el Dano base. \n";
                std::cout << "(Debe ser un numero entero entre 10 y 60, y multiplo de 10): ";
                while (!(std::cin >> dano_base) || dano_base < 10 || dano_base > 60 || dano_base % 10 != 0) {
                    std::cout << "----------- ERROR -----------\n";
                    std::cout << "El valor ingresado es: " << dano_base <<"\n";   
                    std::cout << "Debe ser un numero entero entre 10 y 60, y multiplo de 10.\n";    
                    std::cout << "Intente nuevamente.\n" << endl;
                    
                    std::cin.clear();
                    std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                }
                std::cin.ignore();

                int salud_base;
                std::cout << "\nIngrese la Salud base. \n";
                std::cout << "(Debe ser un numero entero entre 100 y 300, y multiplo de 50): ";
                while (!(std::cin >> salud_base) || salud_base < 100 || salud_base > 300 || salud_base % 50 != 0) {
                    std::cout << "----------- ERROR -----------\n";
                    std::cout << "El valor ingresado es: " << salud_base <<"\n";   
                    std::cout << "Debe ser un numero entero entre 100 y 300, y multiplo de 50.\n";    
                    std::cout << "Intente nuevamente.\n" << endl;
                    std::cin.clear();
                    std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                }
                std::cin.ignore();

                int rapidez_base;
                std::cout << "\nIngrese la Rapidez base. \n";
                std::cout << "(Debe ser un numero entero entre 50 y 200, y multiplo de 50): ";
                std::cout << "(Valores admitidos: 50, 100, 150, 200): \n" << endl;
                while (!(std::cin >> rapidez_base) || rapidez_base < 50 || rapidez_base > 200 || rapidez_base % 50 != 0) {
                    std::cout << "----------- ERROR -----------\n";
                    std::cout << "El valor ingresado es: " << salud_base <<"\n";   
                    std::cout << "Debe ser un numero entero entre 50 y 200, y multiplo de 50.\n";    
                    std::cout << "Intente nuevamente.\n" << endl;
                    std::cin.clear();
                    std::cin.ignore(numeric_limits<streamsize>::max(), '\n');
                }
                std::cin.ignore();
                
                cout << "\nCreando datos...\n"<<endl;
                this_thread::sleep_for(chrono::seconds(3));
                crearOrco(cabezaOrco, nombre, dano_base, salud_base, rapidez_base);
                pausa();
                break;
            }
            case 2: {
                mostrarOrcos(cabezaOrco);
                pausa();
                break;
            }
            case 3: {
                modificarOrco(cabezaOrco);
                break;
            }
            case 4: {
                eliminarOrco(cabezaOrco);
                break; 
            }
            case 5: {
                cout << "Volviendo al menu anterior...\n";
                this_thread::sleep_for(chrono::seconds(3));
                break;
            }
            default:
                cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
                break;
            
        }
    } while (opcionOrco != 5);
}






















// FUNCIONES SALAS

// Funcion para limpiar el buffer de entrada
void limpiarBuffer() {
    cin.clear();
    while (cin.get() != '\n');
}

// Funciones para gestionar salas    

void inicializarListaSalas(ListaSalas* lista) {
    lista->cabeza = nullptr;
    lista->cantidadSalas = 0;

    // Anadir una Sala predeterminada
    Sala* nuevaSala = crearSala("Gruta de la Perdicion", 123);
    lista->cabeza = nuevaSala; 
    lista->cantidadSalas++;
}

void agregarSala(ListaSalas* lista) {
    system("cls");
    cout << "\n----- Crear Nueva Sala -----\n"<<endl;
    string nombre_sala = obtenerNombre("Ingrese el Nombre de la anueva Sala (maximo 20 caracteres): ");
    
    int sala_id;
    cout << "\nIngrese el ID de la sala\n";
    cout << "(Debe ser un numero entero de tres digitos entre 100 y 999): ";
    while (!(cin >> sala_id) || sala_id <100 || sala_id >999) {
        cout << "----------- ERROR -----------\n";
        cout << "El valor ingresado es: " << sala_id;   
        cout << "Debe ser un numero entero de tres digitos entre 100 y 999.\n";    
        cout << "Intente nuevamente." << endl;
        cin.clear();
        cin.ignore(10000, '\n');
    }
    cin.ignore(); 

    // Crear la nueva Sala utilizando la funcion
    Sala* nuevaSala = crearSala(nombre_sala, sala_id);




    // Agregar la nueva sala a la lista
    if (lista->cabeza == nullptr) {
        lista->cabeza = nuevaSala;
    } else {
        Sala* actual = lista->cabeza;
        while (actual->siguiente != nullptr) {
            actual = actual->siguiente;
        }
        actual->siguiente = nuevaSala;
    }
    lista->cantidadSalas++;
    cout << "\nCreando datos...\n"<<endl;
    this_thread::sleep_for(chrono::seconds(3));
    cout << "Sala '" << nombre_sala << "' agregada exitosamente!\n";
    pausa();
}

// Funcion para listar todas las salas
void VerSalas(const ListaSalas* lista) {
    if (lista->cabeza == nullptr) {
        cout << "\n----- Lista vacia -----\n";
        cout << "\nNo hay salas disponibles.\n";
        pausa();
        return;
    }

    Sala* actual = lista->cabeza;
    int i = 1;
    

    cout << "\n----- Lista de Salas Disponibles -----\n";
    while (actual != nullptr) {
        cout << i << ". ID: " << actual->id_sala << endl;
        cout << "   Nombre: " << actual->nombre 
             << " | Salas adyacentes: Coming Soon... \n" << endl;
        actual = actual->siguiente;
        i++;
    }
    cout << "\n------------------------------------------------------\n";
}

// Modificar una sala
void modificarSala(ListaSalas* listaSalas) {
    if (listaSalas->cabeza == nullptr) {
        cout << "\n----- Lista vacia -----\n";
        cout << "\nNo hay Salas disponibles para modificar.\n";
        pausa();
        return;
    }

    VerSalas(listaSalas);

    int seleccionSala;
    cout << "Ingrese el numero de la Sala que desea modificar: ";
    cin >> seleccionSala;
    
    cin.clear();
    (cin.ignore(1000,'\n'));

    Sala* actual = listaSalas->cabeza;
    int indice = 1;
    while (actual != nullptr && indice < seleccionSala) {
        actual = actual->siguiente;
        indice++;
    }

    if (actual == nullptr) {
        std::cout << "----------- ERROR -----------";
        std::cout << "\nSeleccion invalida.";
        cout << "Intente nuevamente.\n."<<endl;
        return;
    }

    int opcion;
    system("cls");
    cout << "\n--- Que desea modificar de la Sala '" << actual->nombre << "'? ---\n";
    cout << "1. Nombre de la sala (actual: " << actual->nombre << ").\n";
    cout << "2. ID de la sala (actual: " << actual->id_sala << ").\n";
    cout << "3. Finalizar modificacion\n"<<endl;
    cout << "Ingrese el numero correspondiente a la opcion que desea seleccionar: ";
    cin >> opcion;
    
    cin.clear();
    (cin.ignore(1000,'\n'));

    switch (opcion) {
        case 1: {
            string nombre_sala = obtenerNombre("Ingrese el nuevo Nombre de la Sala '" + actual->nombre+ ", ' ,(maximo 20 caracteres): ");
            actual->nombre = nombre_sala;
            cout << "\nActualizando datos...\n"<<endl;
            this_thread::sleep_for(chrono::seconds(3));
            cout << "Nombre de Sala actualizado a '" << actual->nombre << "' correctamente.\n";
            pausa();
            break;
        }
        case 2: {
            VerSalas(listaSalas);
            int nuevo_id;
            cout << "Ingrese el nuevo ID de la Sala\n";
            cout << "(Debe ser un numero entero de tres digitos entre 100 y 999): ";
            while (!(cin >> nuevo_id) || nuevo_id <100 || nuevo_id >999) {
                cout << "----------- ERROR -----------\n";
                cout << "El valor ingresado es: " << nuevo_id;   
                cout << "Debe ser un numero entero de tres digitos, entre 100 y 999.\n";    
                cout << "Intente nuevamente." << endl;
            }

            Sala* SalaActual = listaSalas->cabeza;
            for (int i = 1; i < seleccionSala; ++i) {
                SalaActual = SalaActual->siguiente;
            }
                
            actual->id_sala = nuevo_id;
            cout << "\nActualizando datos...\n"<<endl;
            this_thread::sleep_for(chrono::seconds(3));
            cout << "El ID de la Sala " << SalaActual->nombre << " fue actualizado a " << SalaActual->id_sala<< " correctamente.\n";
            pausa();
        
            break;
        }
        default:
            cout << "Opcion del menu invalida.\n";
            pausa();
            return;
    }

    cout << "\nSala '" << actual->nombre << "' modificada exitosamente!\n"<<endl;
    pausa();
}

// Eliminar una sala
void eliminarSala(ListaSalas* listaSalas) {
    if (listaSalas->cantidadSalas == 0) {
        cout << "\n----- Lista vacia -----\n";
        cout << "No hay salas disponibles para eliminar.\n";
        pausa();
        return;
    }

    VerSalas(listaSalas);

    int seleccion;
    cout << "\nIngrese el numero de la Sala que desea eliminar (1-" << listaSalas->cantidadSalas << "): ";
    while (!(cin >> seleccion) || seleccion < 1 || seleccion > listaSalas->cantidadSalas) {
        cout << "----------- ERROR -----------";
        cout << "\nEl numero ingresado es:" << seleccion << endl;
        cout << "Entrada invalida: Debe ser un numero entero entre 1 y " << listaSalas->cantidadSalas << ": ";
        cout << "Intente nuevamente.\n."<<endl;
        cin.clear();
        cin.ignore(10000, '\n');
    }
    cin.ignore();

    Sala* actual = listaSalas->cabeza;
    Sala* anterior = nullptr;
    int indice = 1;

    // Buscar la sala seleccionada
    while (actual != nullptr && indice < seleccion) {
        anterior = actual;
        actual = actual->siguiente;
        indice++;
    }

    if (actual == nullptr) {
        cout << "----------- ERROR -----------\n";
        cout << "Seleccion invalida.\n";
        cout << "Intente nuevamente.\n"<<endl;
        return;
    }

    // Eliminar la sala seleccionada
    if (anterior == nullptr) {
        // Eliminar la primera sala
        listaSalas->cabeza = actual->siguiente;
    } else {
        // Eliminar una sala intermedia o final
        anterior->siguiente = actual->siguiente;
    }

    delete actual;
    listaSalas->cantidadSalas--;
    cout << "\nEliminando datos...\n"<<endl;
    this_thread::sleep_for(chrono::seconds(3));
    cout << "Sala eliminada exitosamente!\n"<<endl;
    pausa();
}


// liberar memoria
void limpiarSalas(ListaSalas* listaSalas) {
    Sala* actual = listaSalas->cabeza;
    while (actual != nullptr) {
        Sala* siguiente = actual->siguiente;
        delete actual; // Liberar la memoria del nodo actual
        actual = siguiente;
    }
    listaSalas->cabeza = nullptr; // Asegurarse de que la lista este vacia
    listaSalas->cantidadSalas = 0; // Reiniciar el contador de especies
    cout << "La memoria de Salas fue eliminada correctamente.\n";
}


// Funcion principal con el menu
void mostrarMenuSalas(ListaSalas* listaSalas) {
    int opcionSala;

    do {
        system("cls");
        cout << "\n--- GESTION DE SALAS ---\n";
        cout << "1. Anadir nueva Sala.\n";
        cout << "2. Ver Salas Disponibles.\n";
        cout << "3. Modificar Sala Existente.\n";
        cout << "4. Eliminar una Sala.\n";
        cout << "5. Volver al menu anterior.\n"<<endl;
        cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        cin >> opcionSala;
       
        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcionSala) {
            case 1:
                agregarSala(listaSalas);
                break;
            case 2:
                VerSalas(listaSalas);
                pausa();
                break;
            case 3:
                modificarSala(listaSalas);
                break;
            case 4:
                eliminarSala(listaSalas);
                break;
            case 5:
                cout << "\nVolviendo al menu principal...\n";
                this_thread::sleep_for(chrono::seconds(3));
                system("cls");
                break;
            default:
                cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcionSala != 5);
}
























































// FUNCIONES Y CLASES SECCIoN IMPLEMENTOS (ARMA, CURA, DEFENSA, PODER MaGICO)

// menu para MOSTRAR todos los implementos por separado
void mostrarMenuImplemento() {
    int opcionx = 0;
    

    do {
        system("cls");
        cout << "\n--- GESTION DE IMPLEMENTOS ---\n";
        cout << "1. Administrar implementos de Ataque.\n";
        cout << "2. Administrar implementos de Curacion.\n";
        cout << "3. Administrar implementos de Defensa.\n";
        cout << "4. Administrar Poderes Magicos.\n";
        cout << "5. Volver al menu anterior.\n"<<endl;
        cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
        cin >> opcionx;

        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcionx) {
            case 1: {
                gestionarArma(); 
                break;
            }
            case 2:
                gestionarCura(); 
                break;

            case 3:
                gestionarDefensa(); 
                break;

            case 4:
                gestionarPoder_Magico();
                break;

            case 5:
                cout << "\nVolviendo al menu principal...\n";
                this_thread::sleep_for(chrono::seconds(3));
                break;

            default:
                cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcionx != 5);
}














// FUNCIONES PRINCIPALES DEL JUEGO

void bienvenida(){
    cout << "\n               Bienvenvido a Khazad-Dum!\n";
    cout << "\n       Mucho exito en esta emocionante aventura!\n"<<endl;
    this_thread::sleep_for(chrono::seconds(2));
    cout << "\n                                       Cargando Datos...\n"<<endl;
    this_thread::sleep_for(chrono::seconds(4));
    cout << "\nPresione ENTER para adentrarnos en el mundo magico...";
    cin.get(); 
    system("cls");

}

void mostrarMenuPrincipal() {

    system("cls");
    
    cout << "\n     -----   K H A Z A D    D U M    -----\n";
    cout << "Desarrollado por: Aguilar, Aponte, Arreaza, Camejo\n"<<endl;
    cout << "\n-----  Menu Principal  -----\n"<<endl;
    cout << "1. Comenzar a jugar!\n";
    cout << "2. Ver elementos del juego (CRUD)\n";
    cout << "3. Salir del juego\n"<<endl;
    cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
}

void mostrarMenuElementos() {
    system("cls");
    cout << "\n--- GESTION DE ELEMENTOS DEL JUEGO ---\n";
    cout << "1. Administrar Heroes.\n";
    cout << "2. Administrar Orcos.\n";
    cout << "3. Administrar Implementos.\n";
    cout << "4. Administrar Salas.\n";
    cout << "5. Regresar Al Menu Principal.\n"<<endl;
    cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
}


void salir() 
{
    system("cls");
    cout<<"\nGracias por jugar Khazad-dum!" << endl;
    cout<<"Hasta la proxima aventura!\n" << endl;
	system("exit");
}

















// FUNCIoN PRINCIPAL

int main() {
    
    
    //Inicializando 
    int opcion,opcion2,opcion1;
    ListaArma ListaArma;
    ListaCura listaCura;
    ListaPoder_Magico listaPoder_Magico;
    ListaDefensa ListaDefensa;
    ListaEspecies listaEspeciesGlobal;
    ListaSalas listaSalas;
    inicializarListaSalas(&listaSalas);
    Especie_Orco* cabezaOrco;
    inicializarListaEspecies(&listaEspeciesGlobal);
    Especie_Orco *cabeza_especies_orco = nullptr;

    ListaHeroes listaHeroes;
    inicializarListaHeroes(&listaHeroes, &listaEspeciesGlobal);


    bienvenida();

    do {
        
        mostrarMenuPrincipal();
        std::cin >> opcion;

        cin.clear();
        (cin.ignore(1000,'\n'));

        switch (opcion) {
            case 1: {
                std::cout << "\nComing Soon...\n";
                std::cout << "Regresando al Menu Principal...\n";
                this_thread::sleep_for(chrono::seconds(4));
                system("cls");
                break;
            }
            case 2:
                do {
                    mostrarMenuElementos();
                    std::cin >> opcion2;

                    cin.clear();
                    (cin.ignore(1000,'\n'));

                    switch (opcion2) {
                        case 1: {
                            do {
                                system("cls");
                                cout << endl << "--- MENU PERSONAJES ---" << endl;
                                cout << "1. Gestionar Heroes" << endl;
                                cout << "2. Gestionar Especies" << endl;
                                cout << "3. Volver al Menu Anterior" << endl;
                                cout << "\nIngrese el numero correspondiente a la opcion que desea seleccionar: ";
                                cin >> opcion1;
                                

                                cin.clear();
                                (cin.ignore(1000,'\n'));

                                cout << "" << endl;
                                switch (opcion1) {
                                    case 1: 
                                        gestionarPersonajes(&listaHeroes, &listaEspeciesGlobal);
                                        break;
                                    case 2:
                                        gestionarEspecies(&listaHeroes, &listaEspeciesGlobal);
                                        break;
                                    case 3:
                                        cout << "Volviendo al menu anterior...\n";
                                        this_thread::sleep_for(chrono::seconds(3));
                                        break;
                                    default:
                                        cout << "\nOpcion invalida. Intente de nuevo.\n";
                                        pausa();
                                }
                            } while (opcion1 != 3);
                                break;
                        }
                        case 2: {
                            menuOrcos(cabeza_especies_orco);
                            break;
                        }
                        case 3:
                            mostrarMenuImplemento();
                            break;                      
                        case 4:
                            mostrarMenuSalas(&listaSalas);  
                            break;
                        case 5:
                            std::cout << "Volviendo al menu anterior...\n";
                            this_thread::sleep_for(chrono::seconds(3));
                            break;
                        default:
                            std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                            pausa();
                    }
                } while(opcion2 != 5);
                break;
            case 3:
                std::cout << "\nSaliendo del juego...\n";
                this_thread::sleep_for(chrono::seconds(4));
                salir();
                break;
            default:
                std::cout << "\nOpcion invalida. Intente de nuevo.\n";
                pausa();
        }
    } while (opcion != 3);
                
    // Liberamos la memoria utilizada por la lista
    limpiarSalas(&listaSalas);             
    limpiarHeroes(&listaHeroes);
    limpiarEspecies(&listaEspeciesGlobal);
    liberarEstructura(cabezaOrco);
    // Los implementos tienen destructores para limpiar la memoria

    return 0;                           
}                                       
